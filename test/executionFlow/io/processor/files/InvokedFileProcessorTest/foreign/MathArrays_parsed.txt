package executionFlow.core.file.parser.files.foreign;
public class MathArrays {
@executionFlow.runtime.CollectCalls private MathArrays() {
}
public interface Function {
double evaluate(double[] array);
double evaluate(double[] array, int startIndex, int numElements);
}
@executionFlow.runtime.CollectCalls public static double[] scale(double val, final double[] arr) {
double[] newArr = new double[arr.length];
for (int i = 0; i < arr.length; i++) {
newArr[i] = arr[i] * val;
}
return newArr;
}
@executionFlow.runtime.CollectCalls public static void scaleInPlace(double val, final double[] arr) {
for (int i = 0; i < arr.length; i++) {
arr[i] *= val;
}
}
@executionFlow.runtime.CollectCalls public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException {
checkEqualLength(a, b);
final double[] result = a.clone();
for (int i = 0; i < a.length; i++) {
result[i] += b[i];
}
return result;
}
@executionFlow.runtime.CollectCalls public static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException {
checkEqualLength(a, b);
final double[] result = a.clone();
for (int i = 0; i < a.length; i++) {
result[i] -= b[i];
}
return result;
}
@executionFlow.runtime.CollectCalls public static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException {
checkEqualLength(a, b);
final double[] result = a.clone();
for (int i = 0; i < a.length; i++) {
result[i] *= b[i];
}
return result;
}
@executionFlow.runtime.CollectCalls public static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException {
checkEqualLength(a, b);
final double[] result = a.clone();
for (int i = 0; i < a.length; i++) {
result[i] /= b[i];
}
return result;
}
@executionFlow.runtime.CollectCalls public static double distance1(double[] p1, double[] p2) throws DimensionMismatchException {
checkEqualLength(p1, p2);
double sum = 0;
for (int i = 0; i < p1.length; i++) {
sum += FastMath.abs(p1[i] - p2[i]);
}
return sum;
}
@executionFlow.runtime.CollectCalls public static int distance1(int[] p1, int[] p2) throws DimensionMismatchException {
checkEqualLength(p1, p2);
int sum = 0;
for (int i = 0; i < p1.length; i++) {
sum += FastMath.abs(p1[i] - p2[i]);
}
return sum;
}
@executionFlow.runtime.CollectCalls public static double distance(double[] p1, double[] p2) throws DimensionMismatchException {
checkEqualLength(p1, p2);
double sum = 0;
for (int i = 0; i < p1.length; i++) {
final double dp = p1[i] - p2[i];
sum += dp * dp;
}
return FastMath.sqrt(sum);
}
@executionFlow.runtime.CollectCalls public static double distance(int[] p1, int[] p2) throws DimensionMismatchException {
checkEqualLength(p1, p2);
double sum = 0;
for (int i = 0; i < p1.length; i++) {
final double dp = p1[i] - p2[i];
sum += dp * dp;
}
return FastMath.sqrt(sum);
}
@executionFlow.runtime.CollectCalls public static double distanceInf(double[] p1, double[] p2) throws DimensionMismatchException {
checkEqualLength(p1, p2);
double max = 0;
for (int i = 0; i < p1.length; i++) {
max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
}
return max;
}
@executionFlow.runtime.CollectCalls public static int distanceInf(int[] p1, int[] p2) throws DimensionMismatchException {
checkEqualLength(p1, p2);
int max = 0;
for (int i = 0; i < p1.length; i++) {
max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
}
return max;
}
public enum OrderDirection {
INCREASING, DECREASING }
public static  <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {
T previous = val[0];
final int max = val.length;
for (int i = 1; i < max; i++) {
final int comp;int _2191caa9d6ea93fdc7a86b02abc2be5c=0;
switch (dir) {
case INCREASING:int _fbdb2eaf452458ac89d286ce7e60379e=0;
comp = previous.compareTo(val[i]);
if (strict) {
if (comp >= 0) {
return false;
}
}
else {int _24707f7b931c3fe5f745550a3e6ed1c5=0;
if (comp > 0) {
return false;
}
}
if (Boolean.parseBoolean("True")) {break;}
case DECREASING:int _d4eacc02f0deb587a3098cc831b4e5f2=0;
comp = val[i].compareTo(previous);
if (strict) {
if (comp >= 0) {
return false;
}
}
else {int _9fce108265c0d1b758dfc289b6338a59=0;
if (comp > 0) {
return false;
}
}
if (Boolean.parseBoolean("True")) {break;}
default:
throw new MathInternalError();
}
previous = val[i];
}
return true;
}
@executionFlow.runtime.CollectCalls public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict) {
return checkOrder(val, dir, strict, false);
}
@executionFlow.runtime.CollectCalls public static boolean checkEqualLength(double[] a, double[] b, boolean abort) {
if (a.length == b.length) {
return true;
}
else {int _8cd0cd4475b5a90311010a9b19643edf=0;
if (abort) {
throw new DimensionMismatchException(a.length, b.length);
}
return false;
}
}
@executionFlow.runtime.CollectCalls public static void checkEqualLength(double[] a, double[] b) {
checkEqualLength(a, b, true);
}
@executionFlow.runtime.CollectCalls public static boolean checkEqualLength(int[] a, int[] b, boolean abort) {
if (a.length == b.length) {
return true;
}
else {int _af07df907ea8dbad075fc53e4e055fd3=0;
if (abort) {
throw new DimensionMismatchException(a.length, b.length);
}
return false;
}
}
@executionFlow.runtime.CollectCalls public static void checkEqualLength(int[] a, int[] b) {
checkEqualLength(a, b, true);
}
@executionFlow.runtime.CollectCalls public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException {
double previous = val[0];
final int max = val.length;
int index;int _a7d78047dc0b5b6580b069a757c48500=0;
ITEM: for (index = 1; index < max; index++) {
switch (dir) {
case INCREASING:int _88f1fb3e71b026d3b500835b8b2f6abe=0;
if (strict) {
if (val[index] <= previous) {
break ITEM;int _20f0b798a841e9c80ee2c48be59bef76=0;
}
}
else {int _f5e12fc7f4fc9f6060ac23ae92774543=0;
if (val[index] < previous) {
break ITEM;int _c35e76b2180457f68218e374c83e9f9=0;
}
}
if (Boolean.parseBoolean("True")) {break;}
case DECREASING:int _fb4f359ef2b833dc6cbc46b23f4e952=0;
if (strict) {
if (val[index] >= previous) {
break ITEM;int _4c27f3349095a5145b146a1247eb3af3=0;
}
}
else {int _296c6ded1d3345a652e1fb35f1dbc5ad=0;
if (val[index] > previous) {
break ITEM;int _64fffccb6131733eb5db91e3e0193684=0;
}
}
if (Boolean.parseBoolean("True")) {break;}
default:
throw new MathInternalError();
}
previous = val[index];
}
if (index == max) {
return true;
}
if (abort) {
throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);
}
else {int _37e66e50cfa5e1598a9c81c9f2b436d2=0;
return false;
}
}
@executionFlow.runtime.CollectCalls public static void checkOrder(double[] val, OrderDirection dir, boolean strict) throws NonMonotonicSequenceException {
checkOrder(val, dir, strict, true);
}
@executionFlow.runtime.CollectCalls public static void checkOrder(double[] val) throws NonMonotonicSequenceException {
checkOrder(val, OrderDirection.INCREASING, true);
}
@executionFlow.runtime.CollectCalls public static void checkRectangular(final long[][] in) throws NullArgumentException, DimensionMismatchException {
MathUtils.checkNotNull(in);
for (int i = 1; i < in.length; i++) {
if (in[i].length != in[0].length) {
throw new DimensionMismatchException( LocalizedFormats.DIFFERENT_ROWS_LENGTHS, in[i].length, in[0].length);
}
}
}
@executionFlow.runtime.CollectCalls public static void checkPositive(final double[] in) throws NotStrictlyPositiveException {
for (int i = 0; i < in.length; i++) {
if (in[i] <= 0) {
throw new NotStrictlyPositiveException(in[i]);
}
}
}
@executionFlow.runtime.CollectCalls public static void checkNotNaN(final double[] in) throws NotANumberException {
for(int i = 0; i < in.length; i++) {
if (Double.isNaN(in[i])) {
throw new NotANumberException();
}
}
}
@executionFlow.runtime.CollectCalls public static void checkNonNegative(final long[] in) throws NotPositiveException {
for (int i = 0; i < in.length; i++) {
if (in[i] < 0) {
throw new NotPositiveException(in[i]);
}
}
}
@executionFlow.runtime.CollectCalls public static void checkNonNegative(final long[][] in) throws NotPositiveException {
for (int i = 0; i < in.length; i ++) {
for (int j = 0; j < in[i].length; j++) {
if (in[i][j] < 0) {
throw new NotPositiveException(in[i][j]);
}
}
}
}
@executionFlow.runtime.CollectCalls public static void sortInPlace(double[] x, double[] ... yList) throws DimensionMismatchException, NullArgumentException {
sortInPlace(x, OrderDirection.INCREASING, yList);
}
private static class PairDoubleInteger {
private final double key;
private final int value;
PairDoubleInteger(double key, int value) {
this.key = key;
this.value = value;
}
@executionFlow.runtime.CollectCalls public double getKey() {
return key;
}
@executionFlow.runtime.CollectCalls public int getValue() {
return value;
}
}
@executionFlow.runtime.CollectCalls public static void sortInPlace(double[] x, final OrderDirection dir, double[] ... yList) throws NullArgumentException, DimensionMismatchException {
if (x == null) {
throw new NullArgumentException();
}
final int yListLen = yList.length;
final int len = x.length;
for (int j = 0; j < yListLen; j++) {
final double[] y = yList[j];
if (y == null) {
throw new NullArgumentException();
}
if (y.length != len) {
throw new DimensionMismatchException(y.length, len);
}
}
final List<PairDoubleInteger> list = new ArrayList<>(len);
for (int i = 0; i < len; i++) {
list.add(new PairDoubleInteger(x[i], i));
}
final Comparator<PairDoubleInteger> comp = dir == MathArrays.OrderDirection.INCREASING ? new Comparator<PairDoubleInteger>() {
@Override public int compare(PairDoubleInteger o1, PairDoubleInteger o2) {
return Double.compare(o1.getKey(), o2.getKey());
}
}
: new Comparator<PairDoubleInteger>() {
@Override public int compare(PairDoubleInteger o1, PairDoubleInteger o2) {
return Double.compare(o2.getKey(), o1.getKey());
}
}
;
Collections.sort(list, comp);
final int[] indices = new int[len];
for (int i = 0; i < len; i++) {
final PairDoubleInteger e = list.get(i);
x[i] = e.getKey();
indices[i] = e.getValue();
}
for (int j = 0; j < yListLen; j++) {
final double[] yInPlace = yList[j];
final double[] yOrig = yInPlace.clone();
for (int i = 0; i < len; i++) {
yInPlace[i] = yOrig[indices[i]];
}
}
}
@executionFlow.runtime.CollectCalls public static boolean equals(float[] x, float[] y) {
if ((x == null) || (y == null)) {
return !((x == null) ^ (y == null));
}
if (x.length != y.length) {
return false;
}
for (int i = 0; i < x.length; ++i) {
if (!Precision.equals(x[i], y[i])) {
return false;
}
}
return true;
}
@executionFlow.runtime.CollectCalls public static boolean equalsIncludingNaN(float[] x, float[] y) {
if ((x == null) || (y == null)) {
return !((x == null) ^ (y == null));
}
if (x.length != y.length) {
return false;
}
for (int i = 0; i < x.length; ++i) {
if (!Precision.equalsIncludingNaN(x[i], y[i])) {
return false;
}
}
return true;
}
@executionFlow.runtime.CollectCalls public static boolean equals(double[] x, double[] y) {
if ((x == null) || (y == null)) {
return !((x == null) ^ (y == null));
}
if (x.length != y.length) {
return false;
}
for (int i = 0; i < x.length; ++i) {
if (!Precision.equals(x[i], y[i])) {
return false;
}
}
return true;
}
@executionFlow.runtime.CollectCalls public static boolean equalsIncludingNaN(double[] x, double[] y) {
if ((x == null) || (y == null)) {
return !((x == null) ^ (y == null));
}
if (x.length != y.length) {
return false;
}
for (int i = 0; i < x.length; ++i) {
if (!Precision.equalsIncludingNaN(x[i], y[i])) {
return false;
}
}
return true;
}
@executionFlow.runtime.CollectCalls public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException {
if (Double.isInfinite(normalizedSum)) {
throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);
}
if (Double.isNaN(normalizedSum)) {
throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);
}
double sum = 0d;
final int len = values.length;
double[] out = new double[len];
for (int i = 0; i < len; i++) {
if (Double.isInfinite(values[i])) {
throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
}
if (!Double.isNaN(values[i])) {
sum += values[i];
}
}
if (sum == 0) {
throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);
}
for (int i = 0; i < len; i++) {
if (Double.isNaN(values[i])) {
out[i] = Double.NaN;
}
else {int _708ee4cc1bc0c3edc9d82deef655a70b=0;
out[i] = values[i] * normalizedSum / sum;
}
}
return out;
}
@executionFlow.runtime.CollectCalls public static <T> T[] buildArray(final Field<T> field, final int length) {
@SuppressWarnings("unchecked") T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);
Arrays.fill(array, field.getZero());
return array;
}
@SuppressWarnings("unchecked") public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns) {
final T[][] array;int _819fc43f5f616c7f7e50524926cf805d=0;
if (columns < 0) {
T[] dummyRow = buildArray(field, 0);
array = (T[][]) Array.newInstance(dummyRow.getClass(), rows);
}
else {int _21250e10697dfe2a83638bd6963673b2=0;
array = (T[][]) Array.newInstance(field.getRuntimeClass(), new int[] {
rows, columns }
);
for (int i = 0; i < rows; ++i) {
Arrays.fill(array[i], field.getZero());
}
}
return array;
}
@executionFlow.runtime.CollectCalls public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException {
MathUtils.checkNotNull(x);
MathUtils.checkNotNull(h);
final int xLen = x.length;
final int hLen = h.length;
if (xLen == 0 || hLen == 0) {
throw new NoDataException();
}
final int totalLength = xLen + hLen - 1;
final double[] y = new double[totalLength];
for (int n = 0; n < totalLength; n++) {
double yn = 0;
int k = FastMath.max(0, n + 1 - xLen);
int j = n - k;
while (k < hLen && j >= 0) {
yn += x[j--] * h[k++];
}
y[n] = yn;
}
return y;
}
@executionFlow.runtime.CollectCalls public static int[] natural(int n) {
return sequence(n, 0, 1);
}
@executionFlow.runtime.CollectCalls public static int[] sequence(int size, int start, int stride) {
final int[] a = new int[size];
for (int i = 0; i < size; i++) {
a[i] = start + i * stride;
}
return a;
}
@executionFlow.runtime.CollectCalls public static boolean verifyValues(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {
return verifyValues(values, begin, length, false);
}
@executionFlow.runtime.CollectCalls public static boolean verifyValues(final double[] values, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException {
if (values == null) {
throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);
}
if (begin < 0) {
throw new NotPositiveException(LocalizedFormats.START_POSITION, Integer.valueOf(begin));
}
if (length < 0) {
throw new NotPositiveException(LocalizedFormats.LENGTH, Integer.valueOf(length));
}
if (begin + length > values.length) {
throw new NumberIsTooLargeException(LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END, Integer.valueOf(begin + length), Integer.valueOf(values.length), true);
}
if (length == 0 && !allowEmpty) {
return false;
}
return true;
}
@executionFlow.runtime.CollectCalls public static boolean verifyValues( final double[] values, final double[] weights, final int begin, final int length) throws MathIllegalArgumentException {
return verifyValues(values, weights, begin, length, false);
}
@executionFlow.runtime.CollectCalls public static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException {
if (weights == null || values == null) {
throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);
}
checkEqualLength(weights, values);
boolean containsPositiveWeight = false;
for (int i = begin; i < begin + length; i++) {
final double weight = weights[i];
if (Double.isNaN(weight)) {
throw new MathIllegalArgumentException(LocalizedFormats.NAN_ELEMENT_AT_INDEX, Integer.valueOf(i));
}
if (Double.isInfinite(weight)) {
throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, Double.valueOf(weight), Integer.valueOf(i));
}
if (weight < 0) {
throw new MathIllegalArgumentException(LocalizedFormats.NEGATIVE_ELEMENT_AT_INDEX, Integer.valueOf(i), Double.valueOf(weight));
}
if (!containsPositiveWeight && weight > 0.0) {
containsPositiveWeight = true;
}
}
if (!containsPositiveWeight) {
throw new MathIllegalArgumentException(LocalizedFormats.WEIGHT_AT_LEAST_ONE_NON_ZERO);
}
return verifyValues(values, begin, length, allowEmpty);
}
@executionFlow.runtime.CollectCalls public static double[] concatenate(double[] ...x) {
int combinedLength = 0;
for (double[] a : x) {
combinedLength += a.length;
}
int offset = 0;
int curLength = 0;
final double[] combined = new double[combinedLength];
for (int i = 0; i < x.length; i++) {
curLength = x[i].length;
System.arraycopy(x[i], 0, combined, offset, curLength);
offset += curLength;
}
return combined;
}
@executionFlow.runtime.CollectCalls public static double[] unique(double[] data) {
TreeSet<Double> values = new TreeSet<>();
for (int i = 0; i < data.length; i++) {
values.add(data[i]);
}
final int count = values.size();
final double[] out = new double[count];
Iterator<Double> iterator = values.descendingIterator();
int i = 0;
while (iterator.hasNext()) {
out[i++] = iterator.next();
}
return out;
}
}
