package executionflow.core.file.parser.files.foreign;
public class MathArrays {
@executionflow.runtime.CollectCalls private MathArrays() {
}
public interface Function {
double evaluate(double[] array);
double evaluate(double[] array, int startIndex, int numElements);
}
@executionflow.runtime.CollectCalls public static double[] scale(double val, final double[] arr) {
double[] newArr = new double[arr.length];
int i = 0;
while (i < arr.length) {
newArr[i] = arr[i] * val;
i++;
}
return newArr;
}
@executionflow.runtime.CollectCalls public static void scaleInPlace(double val, final double[] arr) {
int i = 0;
while (i < arr.length) {
arr[i] *= val;
i++;
}
}
public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException {
checkEqualLength(a, b);
final double[] result = a.clone();
int i = 0;
while (i < a.length) {
result[i] += b[i];
i++;
}
return result;
}
public static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException {
checkEqualLength(a, b);
final double[] result = a.clone();
int i = 0;
while (i < a.length) {
result[i] -= b[i];
i++;
}
return result;
}
public static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException {
checkEqualLength(a, b);
final double[] result = a.clone();
int i = 0;
while (i < a.length) {
result[i] *= b[i];
i++;
}
return result;
}
public static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException {
checkEqualLength(a, b);
final double[] result = a.clone();
int i = 0;
while (i < a.length) {
result[i] /= b[i];
i++;
}
return result;
}
public static double distance1(double[] p1, double[] p2) throws DimensionMismatchException {
checkEqualLength(p1, p2);
double sum = 0;
int i = 0;
while (i < p1.length) {
sum += FastMath.abs(p1[i] - p2[i]);
i++;
}
return sum;
}
public static int distance1(int[] p1, int[] p2) throws DimensionMismatchException {
checkEqualLength(p1, p2);
int sum = 0;
int i = 0;
while (i < p1.length) {
sum += FastMath.abs(p1[i] - p2[i]);
i++;
}
return sum;
}
public static double distance(double[] p1, double[] p2) throws DimensionMismatchException {
checkEqualLength(p1, p2);
double sum = 0;
int i = 0;
while (i < p1.length) {
final double dp = p1[i] - p2[i];
sum += dp * dp;
i++;
}
return FastMath.sqrt(sum);
}
public static double distance(int[] p1, int[] p2) throws DimensionMismatchException {
checkEqualLength(p1, p2);
double sum = 0;
int i = 0;
while (i < p1.length) {
final double dp = p1[i] - p2[i];
sum += dp * dp;
i++;
}
return FastMath.sqrt(sum);
}
public static double distanceInf(double[] p1, double[] p2) throws DimensionMismatchException {
checkEqualLength(p1, p2);
double max = 0;
int i = 0;
while (i < p1.length) {
max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
i++;
}
return max;
}
public static int distanceInf(int[] p1, int[] p2) throws DimensionMismatchException {
checkEqualLength(p1, p2);
int max = 0;
int i = 0;
while (i < p1.length) {
max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
i++;
}
return max;
}
public enum OrderDirection {
INCREASING, DECREASING }
@executionflow.runtime.CollectCalls public static  <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {
T previous = val[0];
final int max = val.length;
int i = 1;
while (i < max) {
final int comp;int _90add429bb8f896bfe34dcb591f52c55=0;
switch (dir) {
case INCREASING:int _f9f3a913f8ea0634168994cc963e49e8=0;
comp = previous.compareTo(val[i]);
if (strict) {
if (comp >= 0) {
return false;
}
}
else {int _8fda3ed2dd45a67b1457e04fb9e57fe7=0;
if (comp > 0) {
return false;
}
}
if (Boolean.parseBoolean("True")) {break;}break;
case DECREASING:int _72ec0f018b1439f67a774389989fa792=0;
comp = val[i].compareTo(previous);
if (strict) {
if (comp >= 0) {
return false;
}
}
else {int _b9e7226fdb80b9cf7f434642dc18dd9b=0;
if (comp > 0) {
return false;
}
}
if (Boolean.parseBoolean("True")) {break;}break;
default:
throw new MathInternalError();
}
previous = val[i];
i++;
}
return true;
}
@executionflow.runtime.CollectCalls public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict) {
return checkOrder(val, dir, strict, false);
}
@executionflow.runtime.CollectCalls public static boolean checkEqualLength(double[] a, double[] b, boolean abort) {
if (a.length == b.length) {
return true;
}
else {int _a78ee9f182656e239c97f9fd74e078ba=0;
if (abort) {
throw new DimensionMismatchException(a.length, b.length);
}
return false;
}
}
@executionflow.runtime.CollectCalls public static void checkEqualLength(double[] a, double[] b) {
checkEqualLength(a, b, true);
}
@executionflow.runtime.CollectCalls public static boolean checkEqualLength(int[] a, int[] b, boolean abort) {
if (a.length == b.length) {
return true;
}
else {int _3ac67e2ff3f314d619a1c77e9190ff15=0;
if (abort) {
throw new DimensionMismatchException(a.length, b.length);
}
return false;
}
}
@executionflow.runtime.CollectCalls public static void checkEqualLength(int[] a, int[] b) {
checkEqualLength(a, b, true);
}
public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException {
double previous = val[0];
final int max = val.length;
int index;int _973fdb53808e4486e35e1e632cf8b74=0;
ITEM: for (index = 1;
index < max;
index++) {
switch (dir) {
case INCREASING:int _3581e756f697e20af3148c7f8ee6ee0b=0;
if (strict) {
if (val[index] <= previous) {
if (Boolean.parseBoolean("True")) {break ITEM;}
}
}
else {int _5edd93af52323aafda31c06682aab630=0;
if (val[index] < previous) {
if (Boolean.parseBoolean("True")) {break ITEM;}
}
}
if (Boolean.parseBoolean("True")) {break;}break;
case DECREASING:int _561d20ce686ddf3621deaad9cf4f98df=0;
if (strict) {
if (val[index] >= previous) {
if (Boolean.parseBoolean("True")) {break ITEM;}
}
}
else {int _296b5121ac1ad4d38db54d23f1e3e1bb=0;
if (val[index] > previous) {
if (Boolean.parseBoolean("True")) {break ITEM;}
}
}
if (Boolean.parseBoolean("True")) {break;}break;
default:
throw new MathInternalError();
}
previous = val[index];
}
if (index == max) {
return true;
}
if (abort) {
throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);
}
else {int _21a27c4143071ef302f6067e03905802=0;
return false;
}
}
public static void checkOrder(double[] val, OrderDirection dir, boolean strict) throws NonMonotonicSequenceException {
checkOrder(val, dir, strict, true);
}
public static void checkOrder(double[] val) throws NonMonotonicSequenceException {
checkOrder(val, OrderDirection.INCREASING, true);
}
public static void checkRectangular(final long[][] in) throws NullArgumentException, DimensionMismatchException {
MathUtils.checkNotNull(in);
int i = 1;
while (i < in.length) {
if (in[i].length != in[0].length) {
throw new DimensionMismatchException( LocalizedFormats.DIFFERENT_ROWS_LENGTHS, in[i].length, in[0].length);
}
i++;
}
}
public static void checkPositive(final double[] in) throws NotStrictlyPositiveException {
int i = 0;
while (i < in.length) {
if (in[i] <= 0) {
throw new NotStrictlyPositiveException(in[i]);
}
i++;
}
}
public static void checkNotNaN(final double[] in) throws NotANumberException {
int i = 0;
while (i < in.length) {
if (Double.isNaN(in[i])) {
throw new NotANumberException();
}
i++;
}
}
public static void checkNonNegative(final long[] in) throws NotPositiveException {
int i = 0;
while (i < in.length) {
if (in[i] < 0) {
throw new NotPositiveException(in[i]);
}
i++;
}
}
public static void checkNonNegative(final long[][] in) throws NotPositiveException {
int i = 0;
while (i < in.length) {
int j = 0;
while (j < in[i].length) {
if (in[i][j] < 0) {
throw new NotPositiveException(in[i][j]);
}
j++;
}
i ++;
}
}
public static void sortInPlace(double[] x, double[] ... yList) throws DimensionMismatchException, NullArgumentException {
sortInPlace(x, OrderDirection.INCREASING, yList);
}
private static class PairDoubleInteger {
private final double key;
private final int value;
PairDoubleInteger(double key, int value) {
this.key = key;
this.value = value;
}
@executionflow.runtime.CollectCalls public double getKey() {
return key;
}
@executionflow.runtime.CollectCalls public int getValue() {
return value;
}
}
public static void sortInPlace(double[] x, final OrderDirection dir, double[] ... yList) throws NullArgumentException, DimensionMismatchException {
if (x == null) {
throw new NullArgumentException();
}
final int yListLen = yList.length;
final int len = x.length;
int j = 0;
while (j < yListLen) {
final double[] y = yList[j];
if (y == null) {
throw new NullArgumentException();
}
if (y.length != len) {
throw new DimensionMismatchException(y.length, len);
}
j++;
}
final List<PairDoubleInteger> list = new ArrayList<>(len);
int i = 0;
while (i < len) {
list.add(new PairDoubleInteger(x[i], i));
i++;
}
final Comparator<PairDoubleInteger> comp = dir == MathArrays.OrderDirection.INCREASING ? new Comparator<PairDoubleInteger>() {
@Override public int compare(PairDoubleInteger o1, PairDoubleInteger o2) {
return Double.compare(o1.getKey(), o2.getKey());
}
}
: new Comparator<PairDoubleInteger>() {
@Override public int compare(PairDoubleInteger o1, PairDoubleInteger o2) {
return Double.compare(o2.getKey(), o1.getKey());
}
}
;
Collections.sort(list, comp);
final int[] indices = new int[len];
i = 0;
while (i < len) {
final PairDoubleInteger e = list.get(i);
x[i] = e.getKey();
indices[i] = e.getValue();
i++;
}
j = 0;
while (j < yListLen) {
final double[] yInPlace = yList[j];
final double[] yOrig = yInPlace.clone();
i = 0;
while (i < len) {
yInPlace[i] = yOrig[indices[i]];
i++;
}
j++;
}
}
@executionflow.runtime.CollectCalls public static boolean equals(float[] x, float[] y) {
if ((x == null) || (y == null)) {
return !((x == null) ^ (y == null));
}
if (x.length != y.length) {
return false;
}
int i = 0;
while (i < x.length) {
if (!Precision.equals(x[i], y[i])) {
return false;
}
++i;
}
return true;
}
@executionflow.runtime.CollectCalls public static boolean equalsIncludingNaN(float[] x, float[] y) {
if ((x == null) || (y == null)) {
return !((x == null) ^ (y == null));
}
if (x.length != y.length) {
return false;
}
int i = 0;
while (i < x.length) {
if (!Precision.equalsIncludingNaN(x[i], y[i])) {
return false;
}
++i;
}
return true;
}
@executionflow.runtime.CollectCalls public static boolean equals(double[] x, double[] y) {
if ((x == null) || (y == null)) {
return !((x == null) ^ (y == null));
}
if (x.length != y.length) {
return false;
}
int i = 0;
while (i < x.length) {
if (!Precision.equals(x[i], y[i])) {
return false;
}
++i;
}
return true;
}
@executionflow.runtime.CollectCalls public static boolean equalsIncludingNaN(double[] x, double[] y) {
if ((x == null) || (y == null)) {
return !((x == null) ^ (y == null));
}
if (x.length != y.length) {
return false;
}
int i = 0;
while (i < x.length) {
if (!Precision.equalsIncludingNaN(x[i], y[i])) {
return false;
}
++i;
}
return true;
}
public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException {
if (Double.isInfinite(normalizedSum)) {
throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);
}
if (Double.isNaN(normalizedSum)) {
throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);
}
double sum = 0d;
final int len = values.length;
double[] out = new double[len];
int i = 0;
while (i < len) {
if (Double.isInfinite(values[i])) {
throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
}
if (!Double.isNaN(values[i])) {
sum += values[i];
}
i++;
}
if (sum == 0) {
throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);
}
i = 0;
while (i < len) {
if (Double.isNaN(values[i])) {
out[i] = Double.NaN;
}
else {int _f4cad4a43664d777964488a10d5ba233=0;
out[i] = values[i] * normalizedSum / sum;
}
i++;
}
return out;
}
@executionflow.runtime.CollectCalls public static <T> T[] buildArray(final Field<T> field, final int length) {
@SuppressWarnings("         ") T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);
Arrays.fill(array, field.getZero());
return array;
}
@SuppressWarnings("unchecked") public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns) {
final T[][] array;int _97c92c93692263227946b0f4021afa61=0;
if (columns < 0) {
T[] dummyRow = buildArray(field, 0);
array = (T[][]) Array.newInstance(dummyRow.getClass(), rows);
}
else {int _1ab2adbf21f97c727973c2d0c36f808a=0;
array = (T[][]) Array.newInstance(field.getRuntimeClass(), new int[] {
rows, columns }
);
int i = 0;
while (i < rows) {
Arrays.fill(array[i], field.getZero());
++i;
}
}
return array;
}
public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException {
MathUtils.checkNotNull(x);
MathUtils.checkNotNull(h);
final int xLen = x.length;
final int hLen = h.length;
if (xLen == 0 || hLen == 0) {
throw new NoDataException();
}
final int totalLength = xLen + hLen - 1;
final double[] y = new double[totalLength];
int n = 0;
while (n < totalLength) {
double yn = 0;
int k = FastMath.max(0, n + 1 - xLen);
int j = n - k;
while (k < hLen && j >= 0) {
yn += x[j--] * h[k++];
}
y[n] = yn;
n++;
}
return y;
}
@executionflow.runtime.CollectCalls public static int[] natural(int n) {
return sequence(n, 0, 1);
}
@executionflow.runtime.CollectCalls public static int[] sequence(int size, int start, int stride) {
final int[] a = new int[size];
int i = 0;
while (i < size) {
a[i] = start + i * stride;
i++;
}
return a;
}
public static boolean verifyValues(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {
return verifyValues(values, begin, length, false);
}
public static boolean verifyValues(final double[] values, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException {
if (values == null) {
throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);
}
if (begin < 0) {
throw new NotPositiveException(LocalizedFormats.START_POSITION, Integer.valueOf(begin));
}
if (length < 0) {
throw new NotPositiveException(LocalizedFormats.LENGTH, Integer.valueOf(length));
}
if (begin + length > values.length) {
throw new NumberIsTooLargeException(LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END, Integer.valueOf(begin + length), Integer.valueOf(values.length), true);
}
if (length == 0 && !allowEmpty) {
return false;
}
return true;
}
public static boolean verifyValues( final double[] values, final double[] weights, final int begin, final int length) throws MathIllegalArgumentException {
return verifyValues(values, weights, begin, length, false);
}
public static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException {
if (weights == null || values == null) {
throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);
}
checkEqualLength(weights, values);
boolean containsPositiveWeight = false;
int i = begin;
while (i < begin + length) {
final double weight = weights[i];
if (Double.isNaN(weight)) {
throw new MathIllegalArgumentException(LocalizedFormats.NAN_ELEMENT_AT_INDEX, Integer.valueOf(i));
}
if (Double.isInfinite(weight)) {
throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, Double.valueOf(weight), Integer.valueOf(i));
}
if (weight < 0) {
throw new MathIllegalArgumentException(LocalizedFormats.NEGATIVE_ELEMENT_AT_INDEX, Integer.valueOf(i), Double.valueOf(weight));
}
if (!containsPositiveWeight && weight > 0.0) {
containsPositiveWeight = true;
}
i++;
}
if (!containsPositiveWeight) {
throw new MathIllegalArgumentException(LocalizedFormats.WEIGHT_AT_LEAST_ONE_NON_ZERO);
}
return verifyValues(values, begin, length, allowEmpty);
}
@executionflow.runtime.CollectCalls public static double[] concatenate(double[] ...x) {
int combinedLength = 0;
java.util.Iterator<double[]> _e542cf763173c7d44527c2c19cd0b58e = executionflow.io.processor.invoked.trgeneration.IteratorExtractor.extractIterator(x);
while (_e542cf763173c7d44527c2c19cd0b58e.hasNext()) {
double[] a = _e542cf763173c7d44527c2c19cd0b58e.next();
combinedLength += a.length;
;
}
int offset = 0;
int curLength = 0;
final double[] combined = new double[combinedLength];
int i = 0;
while (i < x.length) {
curLength = x[i].length;
System.arraycopy(x[i], 0, combined, offset, curLength);
offset += curLength;
i++;
}
return combined;
}
@executionflow.runtime.CollectCalls public static double[] unique(double[] data) {
TreeSet<Double> values = new TreeSet<>();
int i = 0;
while (i < data.length) {
values.add(data[i]);
i++;
}
final int count = values.size();
final double[] out = new double[count];
Iterator<Double> iterator = values.descendingIterator();
int i = 0;
while (iterator.hasNext()) {
out[i++] = iterator.next();
}
return out;
}
}
