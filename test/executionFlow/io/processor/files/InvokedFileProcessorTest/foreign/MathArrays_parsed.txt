package executionflow.core.file.parser.files.foreign;
public class MathArrays {
@executionflow.runtime.CollectCalls private MathArrays() {
}
public interface Function {
double evaluate(double[] array);
double evaluate(double[] array, int startIndex, int numElements);
}
@executionflow.runtime.CollectCalls public static double[] scale(double val, final double[] arr) {
double[] newArr = new double[arr.length];
int i = 0;
while (i < arr.length) {
newArr[i] = arr[i] * val;
i++;
}
return newArr;
}
@executionflow.runtime.CollectCalls public static void scaleInPlace(double val, final double[] arr) {
int i = 0;
while (i < arr.length) {
arr[i] *= val;
i++;
}
}
public static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException {
checkEqualLength(a, b);
final double[] result = a.clone();
int i = 0;
while (i < a.length) {
result[i] += b[i];
i++;
}
return result;
}
public static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException {
checkEqualLength(a, b);
final double[] result = a.clone();
int i = 0;
while (i < a.length) {
result[i] -= b[i];
i++;
}
return result;
}
public static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException {
checkEqualLength(a, b);
final double[] result = a.clone();
int i = 0;
while (i < a.length) {
result[i] *= b[i];
i++;
}
return result;
}
public static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException {
checkEqualLength(a, b);
final double[] result = a.clone();
int i = 0;
while (i < a.length) {
result[i] /= b[i];
i++;
}
return result;
}
public static double distance1(double[] p1, double[] p2) throws DimensionMismatchException {
checkEqualLength(p1, p2);
double sum = 0;
int i = 0;
while (i < p1.length) {
sum += FastMath.abs(p1[i] - p2[i]);
i++;
}
return sum;
}
public static int distance1(int[] p1, int[] p2) throws DimensionMismatchException {
checkEqualLength(p1, p2);
int sum = 0;
int i = 0;
while (i < p1.length) {
sum += FastMath.abs(p1[i] - p2[i]);
i++;
}
return sum;
}
public static double distance(double[] p1, double[] p2) throws DimensionMismatchException {
checkEqualLength(p1, p2);
double sum = 0;
int i = 0;
while (i < p1.length) {
final double dp = p1[i] - p2[i];
sum += dp * dp;
i++;
}
return FastMath.sqrt(sum);
}
public static double distance(int[] p1, int[] p2) throws DimensionMismatchException {
checkEqualLength(p1, p2);
double sum = 0;
int i = 0;
while (i < p1.length) {
final double dp = p1[i] - p2[i];
sum += dp * dp;
i++;
}
return FastMath.sqrt(sum);
}
public static double distanceInf(double[] p1, double[] p2) throws DimensionMismatchException {
checkEqualLength(p1, p2);
double max = 0;
int i = 0;
while (i < p1.length) {
max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
i++;
}
return max;
}
public static int distanceInf(int[] p1, int[] p2) throws DimensionMismatchException {
checkEqualLength(p1, p2);
int max = 0;
int i = 0;
while (i < p1.length) {
max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));
i++;
}
return max;
}
public enum OrderDirection {
INCREASING, DECREASING }
@executionflow.runtime.CollectCalls public static  <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {
T previous = val[0];
final int max = val.length;
int i = 1;
while (i < max) {
final int comp;int _1717f27bffd718d0876a838f7b666631=0;
switch (dir) {
case INCREASING:int _78e80e916d06d83e819df3ac77e1421c=0;
comp = previous.compareTo(val[i]);
if (strict) {
if (comp >= 0) {
return false;
}
}
else {int _f254d4505a8718081a71014a9190f2aa=0;
if (comp > 0) {
return false;
}
}
if (Boolean.parseBoolean("True")) {break;}break;
case DECREASING:int _feed60a8542b7379c5469414bd8f8690=0;
comp = val[i].compareTo(previous);
if (strict) {
if (comp >= 0) {
return false;
}
}
else {int _664d47c9ec211c1dab1ac3795e9b20f4=0;
if (comp > 0) {
return false;
}
}
if (Boolean.parseBoolean("True")) {break;}break;
default:
throw new MathInternalError();
}
previous = val[i];
i++;
}
return true;
}
@executionflow.runtime.CollectCalls public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict) {
return checkOrder(val, dir, strict, false);
}
@executionflow.runtime.CollectCalls public static boolean checkEqualLength(double[] a, double[] b, boolean abort) {
if (a.length == b.length) {
return true;
}
else {int _bb8f4d72eb7fe75c1f79dc14c29d7296=0;
if (abort) {
throw new DimensionMismatchException(a.length, b.length);
}
return false;
}
}
@executionflow.runtime.CollectCalls public static void checkEqualLength(double[] a, double[] b) {
checkEqualLength(a, b, true);
}
@executionflow.runtime.CollectCalls public static boolean checkEqualLength(int[] a, int[] b, boolean abort) {
if (a.length == b.length) {
return true;
}
else {int _e253e06071621950d7893bffc58b4ba5=0;
if (abort) {
throw new DimensionMismatchException(a.length, b.length);
}
return false;
}
}
@executionflow.runtime.CollectCalls public static void checkEqualLength(int[] a, int[] b) {
checkEqualLength(a, b, true);
}
public static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException {
double previous = val[0];
final int max = val.length;
int index;int _4193c7885589c2c4108e2f55b50ef7fe=0;
ITEM: for (index = 1;
index < max;
index++) {
switch (dir) {
case INCREASING:int _15ff77042e74edfad123fcf58026ce89=0;
if (strict) {
if (val[index] <= previous) {
if (Boolean.parseBoolean("True")) {break ITEM;}
}
}
else {int _c90646a37efb44e11d3a863b14fc2f2f=0;
if (val[index] < previous) {
if (Boolean.parseBoolean("True")) {break ITEM;}
}
}
if (Boolean.parseBoolean("True")) {break;}break;
case DECREASING:int _493b1039e98e70f78625f822cef2e845=0;
if (strict) {
if (val[index] >= previous) {
if (Boolean.parseBoolean("True")) {break ITEM;}
}
}
else {int _13f91a00bf7223dfe27adeade91075fb=0;
if (val[index] > previous) {
if (Boolean.parseBoolean("True")) {break ITEM;}
}
}
if (Boolean.parseBoolean("True")) {break;}break;
default:
throw new MathInternalError();
}
previous = val[index];
}
if (index == max) {
return true;
}
if (abort) {
throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);
}
else {int _353b8a9ba9c49820fdc136482cf1b961=0;
return false;
}
}
public static void checkOrder(double[] val, OrderDirection dir, boolean strict) throws NonMonotonicSequenceException {
checkOrder(val, dir, strict, true);
}
public static void checkOrder(double[] val) throws NonMonotonicSequenceException {
checkOrder(val, OrderDirection.INCREASING, true);
}
public static void checkRectangular(final long[][] in) throws NullArgumentException, DimensionMismatchException {
MathUtils.checkNotNull(in);
int i = 1;
while (i < in.length) {
if (in[i].length != in[0].length) {
throw new DimensionMismatchException( LocalizedFormats.DIFFERENT_ROWS_LENGTHS, in[i].length, in[0].length);
}
i++;
}
}
public static void checkPositive(final double[] in) throws NotStrictlyPositiveException {
int i = 0;
while (i < in.length) {
if (in[i] <= 0) {
throw new NotStrictlyPositiveException(in[i]);
}
i++;
}
}
public static void checkNotNaN(final double[] in) throws NotANumberException {
int i = 0;
while (i < in.length) {
if (Double.isNaN(in[i])) {
throw new NotANumberException();
}
i++;
}
}
public static void checkNonNegative(final long[] in) throws NotPositiveException {
int i = 0;
while (i < in.length) {
if (in[i] < 0) {
throw new NotPositiveException(in[i]);
}
i++;
}
}
public static void checkNonNegative(final long[][] in) throws NotPositiveException {
int i = 0;
while (i < in.length) {
int j = 0;
while (j < in[i].length) {
if (in[i][j] < 0) {
throw new NotPositiveException(in[i][j]);
}
j++;
}
i ++;
}
}
public static void sortInPlace(double[] x, double[] ... yList) throws DimensionMismatchException, NullArgumentException {
sortInPlace(x, OrderDirection.INCREASING, yList);
}
private static class PairDoubleInteger {
private final double key;
private final int value;
PairDoubleInteger(double key, int value) {
this.key = key;
this.value = value;
}
@executionflow.runtime.CollectCalls public double getKey() {
return key;
}
@executionflow.runtime.CollectCalls public int getValue() {
return value;
}
}
public static void sortInPlace(double[] x, final OrderDirection dir, double[] ... yList) throws NullArgumentException, DimensionMismatchException {
if (x == null) {
throw new NullArgumentException();
}
final int yListLen = yList.length;
final int len = x.length;
int j = 0;
while (j < yListLen) {
final double[] y = yList[j];
if (y == null) {
throw new NullArgumentException();
}
if (y.length != len) {
throw new DimensionMismatchException(y.length, len);
}
j++;
}
final List<PairDoubleInteger> list = new ArrayList<>(len);
int i = 0;
while (i < len) {
list.add(new PairDoubleInteger(x[i], i));
i++;
}
final Comparator<PairDoubleInteger> comp = dir == MathArrays.OrderDirection.INCREASING ? new Comparator<PairDoubleInteger>() {
@Override public int compare(PairDoubleInteger o1, PairDoubleInteger o2) {
return Double.compare(o1.getKey(), o2.getKey());
}
}
: new Comparator<PairDoubleInteger>() {
@Override public int compare(PairDoubleInteger o1, PairDoubleInteger o2) {
return Double.compare(o2.getKey(), o1.getKey());
}
}
;
Collections.sort(list, comp);
final int[] indices = new int[len];
i = 0;
while (i < len) {
final PairDoubleInteger e = list.get(i);
x[i] = e.getKey();
indices[i] = e.getValue();
i++;
}
j = 0;
while (j < yListLen) {
final double[] yInPlace = yList[j];
final double[] yOrig = yInPlace.clone();
i = 0;
while (i < len) {
yInPlace[i] = yOrig[indices[i]];
i++;
}
j++;
}
}
@executionflow.runtime.CollectCalls public static boolean equals(float[] x, float[] y) {
if ((x == null) || (y == null)) {
return !((x == null) ^ (y == null));
}
if (x.length != y.length) {
return false;
}
int i = 0;
while (i < x.length) {
if (!Precision.equals(x[i], y[i])) {
return false;
}
++i;
}
return true;
}
@executionflow.runtime.CollectCalls public static boolean equalsIncludingNaN(float[] x, float[] y) {
if ((x == null) || (y == null)) {
return !((x == null) ^ (y == null));
}
if (x.length != y.length) {
return false;
}
int i = 0;
while (i < x.length) {
if (!Precision.equalsIncludingNaN(x[i], y[i])) {
return false;
}
++i;
}
return true;
}
@executionflow.runtime.CollectCalls public static boolean equals(double[] x, double[] y) {
if ((x == null) || (y == null)) {
return !((x == null) ^ (y == null));
}
if (x.length != y.length) {
return false;
}
int i = 0;
while (i < x.length) {
if (!Precision.equals(x[i], y[i])) {
return false;
}
++i;
}
return true;
}
@executionflow.runtime.CollectCalls public static boolean equalsIncludingNaN(double[] x, double[] y) {
if ((x == null) || (y == null)) {
return !((x == null) ^ (y == null));
}
if (x.length != y.length) {
return false;
}
int i = 0;
while (i < x.length) {
if (!Precision.equalsIncludingNaN(x[i], y[i])) {
return false;
}
++i;
}
return true;
}
public static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException {
if (Double.isInfinite(normalizedSum)) {
throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);
}
if (Double.isNaN(normalizedSum)) {
throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);
}
double sum = 0d;
final int len = values.length;
double[] out = new double[len];
int i = 0;
while (i < len) {
if (Double.isInfinite(values[i])) {
throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
}
if (!Double.isNaN(values[i])) {
sum += values[i];
}
i++;
}
if (sum == 0) {
throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);
}
i = 0;
while (i < len) {
if (Double.isNaN(values[i])) {
out[i] = Double.NaN;
}
else {int _dd0649a325bed8c62925d567b546d7dc=0;
out[i] = values[i] * normalizedSum / sum;
}
i++;
}
return out;
}
@executionflow.runtime.CollectCalls public static <T> T[] buildArray(final Field<T> field, final int length) {
@SuppressWarnings("         ") T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);
Arrays.fill(array, field.getZero());
return array;
}
@SuppressWarnings("unchecked") public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns) {
final T[][] array;int _49928d3d98f3628caffdb6bb67a9fed=0;
if (columns < 0) {
T[] dummyRow = buildArray(field, 0);
array = (T[][]) Array.newInstance(dummyRow.getClass(), rows);
}
else {int _c91f4cb548563b7c47cd8437433e713=0;
array = (T[][]) Array.newInstance(field.getRuntimeClass(), new int[] {
rows, columns }
);
int i = 0;
while (i < rows) {
Arrays.fill(array[i], field.getZero());
++i;
}
}
return array;
}
public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException {
MathUtils.checkNotNull(x);
MathUtils.checkNotNull(h);
final int xLen = x.length;
final int hLen = h.length;
if (xLen == 0 || hLen == 0) {
throw new NoDataException();
}
final int totalLength = xLen + hLen - 1;
final double[] y = new double[totalLength];
int n = 0;
while (n < totalLength) {
double yn = 0;
int k = FastMath.max(0, n + 1 - xLen);
int j = n - k;
while (k < hLen && j >= 0) {
yn += x[j--] * h[k++];
}
y[n] = yn;
n++;
}
return y;
}
@executionflow.runtime.CollectCalls public static int[] natural(int n) {
return sequence(n, 0, 1);
}
@executionflow.runtime.CollectCalls public static int[] sequence(int size, int start, int stride) {
final int[] a = new int[size];
int i = 0;
while (i < size) {
a[i] = start + i * stride;
i++;
}
return a;
}
public static boolean verifyValues(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {
return verifyValues(values, begin, length, false);
}
public static boolean verifyValues(final double[] values, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException {
if (values == null) {
throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);
}
if (begin < 0) {
throw new NotPositiveException(LocalizedFormats.START_POSITION, Integer.valueOf(begin));
}
if (length < 0) {
throw new NotPositiveException(LocalizedFormats.LENGTH, Integer.valueOf(length));
}
if (begin + length > values.length) {
throw new NumberIsTooLargeException(LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END, Integer.valueOf(begin + length), Integer.valueOf(values.length), true);
}
if (length == 0 && !allowEmpty) {
return false;
}
return true;
}
public static boolean verifyValues( final double[] values, final double[] weights, final int begin, final int length) throws MathIllegalArgumentException {
return verifyValues(values, weights, begin, length, false);
}
public static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException {
if (weights == null || values == null) {
throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);
}
checkEqualLength(weights, values);
boolean containsPositiveWeight = false;
int i = begin;
while (i < begin + length) {
final double weight = weights[i];
if (Double.isNaN(weight)) {
throw new MathIllegalArgumentException(LocalizedFormats.NAN_ELEMENT_AT_INDEX, Integer.valueOf(i));
}
if (Double.isInfinite(weight)) {
throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, Double.valueOf(weight), Integer.valueOf(i));
}
if (weight < 0) {
throw new MathIllegalArgumentException(LocalizedFormats.NEGATIVE_ELEMENT_AT_INDEX, Integer.valueOf(i), Double.valueOf(weight));
}
if (!containsPositiveWeight && weight > 0.0) {
containsPositiveWeight = true;
}
i++;
}
if (!containsPositiveWeight) {
throw new MathIllegalArgumentException(LocalizedFormats.WEIGHT_AT_LEAST_ONE_NON_ZERO);
}
return verifyValues(values, begin, length, allowEmpty);
}
@executionflow.runtime.CollectCalls public static double[] concatenate(double[] ...x) {
int combinedLength = 0;
java.util.Iterator<double[]> _8ec90aaa16eae1ca835ea711009b251e = executionflow.io.processor.invoked.trgeneration.IteratorExtractor.extractIterator(x);
while (_8ec90aaa16eae1ca835ea711009b251e.hasNext()) {
double[] a = _8ec90aaa16eae1ca835ea711009b251e.next();
combinedLength += a.length;
;
}
int offset = 0;
int curLength = 0;
final double[] combined = new double[combinedLength];
int i = 0;
while (i < x.length) {
curLength = x[i].length;
System.arraycopy(x[i], 0, combined, offset, curLength);
offset += curLength;
i++;
}
return combined;
}
@executionflow.runtime.CollectCalls public static double[] unique(double[] data) {
TreeSet<Double> values = new TreeSet<>();
int i = 0;
while (i < data.length) {
values.add(data[i]);
i++;
}
final int count = values.size();
final double[] out = new double[count];
Iterator<Double> iterator = values.descendingIterator();
int i = 0;
while (iterator.hasNext()) {
out[i++] = iterator.next();
}
return out;
}
}
