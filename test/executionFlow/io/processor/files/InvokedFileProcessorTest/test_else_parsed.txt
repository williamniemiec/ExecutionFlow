/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.linear;

import java.io.Serializable;
import java.util.Arrays;
import java.util.Iterator;
import java.util.NoSuchElementException;

import org.apache.commons.math4.TestUtils;
import org.apache.commons.math4.analysis.UnivariateFunction;
import org.apache.commons.math4.analysis.function.Abs;
import org.apache.commons.math4.analysis.function.Acos;
import org.apache.commons.math4.analysis.function.Asin;
import org.apache.commons.math4.analysis.function.Atan;
import org.apache.commons.math4.analysis.function.Cbrt;
import org.apache.commons.math4.analysis.function.Ceil;
import org.apache.commons.math4.analysis.function.Cos;
import org.apache.commons.math4.analysis.function.Cosh;
import org.apache.commons.math4.analysis.function.Exp;
import org.apache.commons.math4.analysis.function.Expm1;
import org.apache.commons.math4.analysis.function.Floor;
import org.apache.commons.math4.analysis.function.Inverse;
import org.apache.commons.math4.analysis.function.Log;
import org.apache.commons.math4.analysis.function.Log10;
import org.apache.commons.math4.analysis.function.Log1p;
import org.apache.commons.math4.analysis.function.Power;
import org.apache.commons.math4.analysis.function.Rint;
import org.apache.commons.math4.analysis.function.Signum;
import org.apache.commons.math4.analysis.function.Sin;
import org.apache.commons.math4.analysis.function.Sinh;
import org.apache.commons.math4.analysis.function.Sqrt;
import org.apache.commons.math4.analysis.function.Tan;
import org.apache.commons.math4.analysis.function.Tanh;
import org.apache.commons.math4.analysis.function.Ulp;
import org.apache.commons.math4.exception.DimensionMismatchException;
import org.apache.commons.math4.exception.MathArithmeticException;
import org.apache.commons.math4.exception.MathUnsupportedOperationException;
import org.apache.commons.math4.exception.NotPositiveException;
import org.apache.commons.math4.exception.NumberIsTooSmallException;
import org.apache.commons.math4.exception.OutOfRangeException;
import org.apache.commons.math4.linear.OpenMapRealVector;
import org.apache.commons.math4.linear.RealMatrix;
import org.apache.commons.math4.linear.RealVector;
import org.apache.commons.math4.linear.RealVectorChangingVisitor;
import org.apache.commons.math4.linear.RealVectorPreservingVisitor;
import org.apache.commons.math4.util.FastMath;
import org.junit.Assert;
import org.junit.Test;


public abstract class RealVectorAbstractTest {

    protected enum BinaryOperation {
        ADD, SUB, MUL, DIV
    }

    /**
     * <p>
     * This is an attempt at covering most particular cases of combining two
     * values. Here {@code x} is the value returned by
     * {@link #getPreferredEntryValue()}, while {@code y} and {@code z} are two
     * "normal" values.
     * </p>
     * <ol>
     *   <li>
     *     Addition: the following cases should be covered
     *     <ul>
     *       <li>{@code (2 * x) + (-x)}</li>
     *       <li>{@code (-x) + 2 * x}</li>
     *       <li>{@code x + y}</li>
     *       <li>{@code y + x}</li>
     *       <li>{@code y + z}</li>
     *       <li>{@code y + (x - y)}</li>
     *       <li>{@code (y - x) + x}</li>
     *     </ul>
     *     The values to be considered are:
     *     {@code x, y, z, 2 * x, -x, x - y, y - x}.
     *   </li>
     *   <li>
     *     Subtraction: the following cases should be covered
     *     <ul>
     *       <li>{@code (2 * x) - x}</li>
     *       <li>{@code x - y}</li>
     *       <li>{@code y - x}</li>
     *       <li>{@code y - z}</li>
     *       <li>{@code y - (y - x)}</li>
     *       <li>{@code (y + x) - y}</li>
     *     </ul>
     *     The values to be considered are: {@code x, y, z, x + y, y - x}.
     *   </li>
     *   <li>
     *     Multiplication
     *     <ul>
     *       <li>{@code (x * x) * (1 / x)}</li>
     *       <li>{@code (1 / x) * (x * x)}</li>
     *       <li>{@code x * y}</li>
     *       <li>{@code y * x}</li>
     *       <li>{@code y * z}</li>
     *     </ul>
     *     The values to be considered are: {@code x, y, z, 1 / x, x * x}.
     *   </li>
     *   <li>
     *     Division
     *     <ul>
     *       <li>{@code (x * x) / x}</li>
     *       <li>{@code x / y}</li>
     *       <li>{@code y / x}</li>
     *       <li>{@code y / z}</li>
     *     </ul>
     *     The values to be considered are: {@code x, y, z, x * x}.
     *   </li>
     * </ol>
     * Also to be considered {@code NaN}, {@code POSITIVE_INFINITY},
     * {@code NEGATIVE_INFINITY}, {@code +0.0}, {@code -0.0}.
     */
    private final double[] values;

    /**
     * Creates a new instance of {@link RealVector}, with specified entries.
     * The returned vector must be of the type currently tested. It should be
     * noted that some tests assume that no references to the specified
     * {@code double[]} are kept in the returned object: if necessary, defensive
     * copy of this array should be made.
     *
     * @param data the entries of the vector to be created
     * @return a new {@link RealVector} of the type to be tested
     */
    public abstract RealVector create(double[] data);

    /**
     * Creates a new instance of {@link RealVector}, with specified entries.
     * The type of the returned vector must be different from the type currently
     * tested. It should be noted that some tests assume that no references to
     * the specified {@code double[]} are kept in the returned object: if
     * necessary, defensive copy of this array should be made.
     *
     * @param data the entries of the vector to be created
     * @return a new {@link RealVector} of an alien type
     */
@executionFlow.runtime.CollectCalls     public RealVector createAlien(double[] data){
        return new RealVectorTestImpl(data);
    }

    /**
     * Returns a preferred value of the entries, to be tested specifically. Some
     * implementations of {@link RealVector} (e.g. {@link OpenMapRealVector}) do
     * not store specific values of entries. In order to ensure that all tests
     * take into account this specific value, some entries of the vectors to be
     * tested are deliberately set to the value returned by the present method.
     * The default implementation returns {@code 0.0}.
     *
     * @return a value which <em>should</em> be present in all vectors to be
     * tested
     */
@executionFlow.runtime.CollectCalls     public double getPreferredEntryValue() {
        return 0.0;
    }

@executionFlow.runtime.CollectCalls     public RealVectorAbstractTest() {
        /*
         * Make sure that x, y, z are three different values. Also, x is the
         * preferred value (e.g. the value which is not stored in sparse
         * implementations).
         */
        final double x = getPreferredEntryValue();
        final double y = x + 1d;
        final double z = y + 1d;

        values =
            new double[] {
                Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY,
                0d, -0d, x, y, z, 2 * x, -x, 1 / x, x * x, x + y, x - y, y - x
            };
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testGetDimension() {
        final double x = getPreferredEntryValue();
        final double[] data1 = {x, x, x, x};
        Assert.assertEquals(data1.length, create(data1).getDimension());
        final double y = x + 1;
        final double[] data2 = {y, y, y, y};
        Assert.assertEquals(data2.length, create(data2).getDimension());
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testGetEntry() {
        final double x = getPreferredEntryValue();
        final double[] data = {x, 1d, 2d, x, x};
        final RealVector v = create(data);
        for (int i = 0; i < data.length; i++) {
            Assert.assertEquals("entry " + i, data[i], v.getEntry(i), 0d);
        }
    }

    @Test(expected=OutOfRangeException.class)
@executionFlow.runtime.CollectCalls     public void testGetEntryInvalidIndex1() {
        create(new double[4]).getEntry(-1);
    }

    @Test(expected=OutOfRangeException.class)
@executionFlow.runtime.CollectCalls     public void testGetEntryInvalidIndex2() {
        create(new double[4]).getEntry(4);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testSetEntry() {
        final double x = getPreferredEntryValue();
        final double[] data = {x, 1d, 2d, x, x};
        final double[] expected = Arrays.copyOf(data, data.length);
        final RealVector actual = create(data);

        /*
         * Try setting to any value.
         */
        for (int i = 0; i < data.length; i++) {
            final double oldValue = data[i];
            final double newValue = oldValue + 1d;
            expected[i] = newValue;
            actual.setEntry(i, newValue);
            TestUtils.assertEquals("while setting entry #" + i, expected,
                actual, 0d);
            expected[i] = oldValue;
            actual.setEntry(i, oldValue);
        }

        /*
         * Try setting to the preferred value.
         */
        for (int i = 0; i < data.length; i++) {
            final double oldValue = data[i];
            final double newValue = x;
            expected[i] = newValue;
            actual.setEntry(i, newValue);
            TestUtils.assertEquals("while setting entry #" + i, expected,
                actual, 0d);
            expected[i] = oldValue;
            actual.setEntry(i, oldValue);
        }
    }

    @Test(expected=OutOfRangeException.class)
@executionFlow.runtime.CollectCalls     public void testSetEntryInvalidIndex1() {
        create(new double[4]).setEntry(-1, getPreferredEntryValue());
    }

    @Test(expected=OutOfRangeException.class)
@executionFlow.runtime.CollectCalls     public void testSetEntryInvalidIndex2() {
        create(new double[4]).setEntry(4, getPreferredEntryValue());
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testAddToEntry() {
        final double x = getPreferredEntryValue();
        final double[] data1 = {x, 1d, 2d, x, x};

        final double[] expected = Arrays.copyOf(data1, data1.length);
        final RealVector actual = create(data1);

        /*
         * Try adding any value.
         */
        double increment = 1d;
        for (int i = 0; i < data1.length; i++) {
            final double oldValue = data1[i];
            expected[i] += increment;
            actual.addToEntry(i, increment);
            TestUtils.assertEquals("while incrementing entry #" + i, expected,
                actual, 0d);
            expected[i] = oldValue;
            actual.setEntry(i, oldValue);
        }

        /*
         * Try incrementing so that result is equal to preferred value.
         */
        for (int i = 0; i < data1.length; i++) {
            final double oldValue = data1[i];
            increment = x - oldValue;
            expected[i] = x;
            actual.addToEntry(i, increment);
            TestUtils.assertEquals("while incrementing entry #" + i, expected,
                actual, 0d);
            expected[i] = oldValue;
            actual.setEntry(i, oldValue);
        }
    }

    @Test(expected=OutOfRangeException.class)
@executionFlow.runtime.CollectCalls     public void testAddToEntryInvalidIndex1() {
        create(new double[3]).addToEntry(-1, getPreferredEntryValue());
    }

    @Test(expected=OutOfRangeException.class)
@executionFlow.runtime.CollectCalls     public void testAddToEntryInvalidIndex2() {
        create(new double[3]).addToEntry(4, getPreferredEntryValue());
    }

@executionFlow.runtime.CollectCalls     private void doTestAppendVector(final String message, final RealVector v1,
        final RealVector v2, final double delta) {

        final int n1 = v1.getDimension();
        final int n2 = v2.getDimension();
        final RealVector v = v1.append(v2);
        Assert.assertEquals(message, n1 + n2, v.getDimension());
        for (int i = 0; i < n1; i++) {
            final String msg = message + ", entry #" + i;
            Assert.assertEquals(msg, v1.getEntry(i), v.getEntry(i), delta);
        }
        for (int i = 0; i < n2; i++) {
            final String msg = message + ", entry #" + (n1 + i);
            Assert.assertEquals(msg, v2.getEntry(i), v.getEntry(n1 + i), delta);
        }
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testAppendVector() {
        final double x = getPreferredEntryValue();
        final double[] data1 =  {x, 1d, 2d, x, x};
        final double[] data2 =  {x, x, 3d, x, 4d, x};

        doTestAppendVector("same type", create(data1), create(data2), 0d);
        doTestAppendVector("mixed types", create(data1), createAlien(data2), 0d);
    }

@executionFlow.runtime.CollectCalls     private void doTestAppendScalar(final String message, final RealVector v,
        final double d, final double delta) {

        final int n = v.getDimension();
        final RealVector w = v.append(d);
        Assert.assertEquals(message, n + 1, w.getDimension());
        for (int i = 0; i < n; i++) {
            final String msg = message + ", entry #" + i;
            Assert.assertEquals(msg, v.getEntry(i), w.getEntry(i), delta);
        }
        final String msg = message + ", entry #" + n;
        Assert.assertEquals(msg, d, w.getEntry(n), delta);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testAppendScalar() {
        final double x = getPreferredEntryValue();
        final double[] data = new double[] {x, 1d, 2d, x, x};

        doTestAppendScalar("", create(data), 1d, 0d);
        doTestAppendScalar("", create(data), x, 0d);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testGetSubVector() {
        final double x = getPreferredEntryValue();
        final double[] data = {x, x, x, 1d, x, 2d, x, x, 3d, x, x, x, 4d, x, x, x};
        final int index = 1;
        final int n = data.length - 5;
        final RealVector actual = create(data).getSubVector(index, n);
        final double[] expected = new double[n];
        System.arraycopy(data, index, expected, 0, n);
        TestUtils.assertEquals("", expected, actual, 0d);
    }

    @Test(expected = OutOfRangeException.class)
@executionFlow.runtime.CollectCalls     public void testGetSubVectorInvalidIndex1() {
        final int n = 10;
        create(new double[n]).getSubVector(-1, 2);
    }

    @Test(expected = OutOfRangeException.class)
@executionFlow.runtime.CollectCalls     public void testGetSubVectorInvalidIndex2() {
        final int n = 10;
        create(new double[n]).getSubVector(n, 2);
    }

    @Test(expected = OutOfRangeException.class)
@executionFlow.runtime.CollectCalls     public void testGetSubVectorInvalidIndex3() {
        final int n = 10;
        create(new double[n]).getSubVector(0, n + 1);
    }

    @Test(expected = NotPositiveException.class)
@executionFlow.runtime.CollectCalls     public void testGetSubVectorInvalidIndex4() {
        final int n = 10;
        create(new double[n]).getSubVector(3, -2);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testSetSubVectorSameType() {
        final double x = getPreferredEntryValue();
        final double[] expected = {x, x, x, 1d, x, 2d, x, x, 3d, x, x, x, 4d, x, x, x};
        final double[] sub = {5d, x, 6d, 7d, 8d};
        final RealVector actual = create(expected);
        final int index = 2;
        actual.setSubVector(index, create(sub));

        for (int i = 0; i < sub.length; i++){
            expected[index + i] = sub[i];
        }
        TestUtils.assertEquals("", expected, actual, 0d);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testSetSubVectorMixedType() {
        final double x = getPreferredEntryValue();
        final double[] expected = {x, x, x, 1d, x, 2d, x, x, 3d, x, x, x, 4d, x, x, x};
        final double[] sub = {5d, x, 6d, 7d, 8d};
        final RealVector actual = create(expected);
        final int index = 2;
        actual.setSubVector(index, createAlien(sub));

        for (int i = 0; i < sub.length; i++){
            expected[index + i] = sub[i];
        }
        TestUtils.assertEquals("", expected, actual, 0d);
    }

    @Test(expected = OutOfRangeException.class)
@executionFlow.runtime.CollectCalls     public void testSetSubVectorInvalidIndex1() {
        create(new double[10]).setSubVector(-1, create(new double[2]));
    }

    @Test(expected = OutOfRangeException.class)
@executionFlow.runtime.CollectCalls     public void testSetSubVectorInvalidIndex2() {
        create(new double[10]).setSubVector(10, create(new double[2]));
    }

    @Test(expected = OutOfRangeException.class)
@executionFlow.runtime.CollectCalls     public void testSetSubVectorInvalidIndex3() {
        create(new double[10]).setSubVector(9, create(new double[2]));
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testIsNaN() {
        final RealVector v = create(new double[] {0, 1, 2});

        Assert.assertFalse(v.isNaN());
        v.setEntry(1, Double.NaN);
        Assert.assertTrue(v.isNaN());
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testIsInfinite() {
        final RealVector v = create(new double[] { 0, 1, 2 });

        Assert.assertFalse(v.isInfinite());
        v.setEntry(0, Double.POSITIVE_INFINITY);
        Assert.assertTrue(v.isInfinite());
        v.setEntry(1, Double.NaN);
        Assert.assertFalse(v.isInfinite());
    }

@executionFlow.runtime.CollectCalls     protected void doTestEbeBinaryOperation(final BinaryOperation op, final boolean mixed, boolean ignoreSpecial) {
        final double[] data1 = new double[values.length * values.length];
        final double[] data2 = new double[values.length * values.length];
        int k = 0;
        for (int i = 0; i < values.length; i++) {
            for (int j = 0; j < values.length; j++) {
                data1[k] = values[i];
                data2[k] = values[j];
                ++k;
            }
        }
        final RealVector v1 = create(data1);
        final RealVector v2 = mixed ? createAlien(data2) : create(data2);
        final RealVector actual;int _3cd7b2248e7d7890b17f1a61aac8ab42=0;
        switch (op) {
            case ADD:int _c1ba3218b5b3179666cc38f477f994e8=0;
                actual = v1.add(v2);
if (Boolean.parseBoolean("True")) {                break;}
            case SUB:int _dd1cf4211533698961e43375f068ed0a=0;
                actual = v1.subtract(v2);
if (Boolean.parseBoolean("True")) {                break;}
            case MUL:int _7c02a058c280a22aba97bc5fc84e1f29=0;
                actual = v1.ebeMultiply(v2);
if (Boolean.parseBoolean("True")) {                break;}
            case DIV:int _2bed76456568c25feee3d2c032f16a45=0;
                actual = v1.ebeDivide(v2);
if (Boolean.parseBoolean("True")) {                break;}
            default:
                throw new AssertionError("unexpected value");
        }
        final double[] expected = new double[data1.length];
        for (int i = 0; i < expected.length; i++) {
            switch (op) {
                case ADD:int _b66d6423b7175122f1643d72aea3dfba=0;
                    expected[i] = data1[i] + data2[i];
if (Boolean.parseBoolean("True")) {                    break;}
                case SUB:int _ed5856df903994f598b6fa6e71b89bb8=0;
                    expected[i] = data1[i] - data2[i];
if (Boolean.parseBoolean("True")) {                    break;}
                case MUL:int _453012712d5b6c6e231ca1d59d66f5e8=0;
                    expected[i] = data1[i] * data2[i];
if (Boolean.parseBoolean("True")) {                    break;}
                case DIV:int _a78bd7702be008b49d8fad31308c3591=0;
                    expected[i] = data1[i] / data2[i];
if (Boolean.parseBoolean("True")) {                    break;}
                default:
                    throw new AssertionError("unexpected value");
            }
        }
        for (int i = 0; i < expected.length; i++) {
            boolean isSpecial = Double.isNaN(expected[i]) || Double.isInfinite(expected[i]);
            if (!(isSpecial && ignoreSpecial)) {
                final String msg = "entry #"+i+", left = "+data1[i]+", right = " + data2[i];
                Assert.assertEquals(msg, expected[i], actual.getEntry(i), 0.0);
            }
        }
    }

@executionFlow.runtime.CollectCalls     private void doTestEbeBinaryOperationDimensionMismatch(final BinaryOperation op) {
        final int n = 10;
        switch (op) {
            case ADD:int _169c5e16ac654b9a0347e100017f574c=0;
                create(new double[n]).add(create(new double[n + 1]));
if (Boolean.parseBoolean("True")) {                break;}
            case SUB:int _e8ba8d0ed0463d39461409caa843d68d=0;
                create(new double[n]).subtract(create(new double[n + 1]));
if (Boolean.parseBoolean("True")) {                break;}
            case MUL:int _ae8b7b3c9782128fb1c33cf94d5cffd9=0;
                create(new double[n]).ebeMultiply(create(new double[n + 1]));
if (Boolean.parseBoolean("True")) {                break;}
            case DIV:int _6bb384f4c86947fc9551476e16098728=0;
                create(new double[n]).ebeDivide(create(new double[n + 1]));
if (Boolean.parseBoolean("True")) {                break;}
            default:
                throw new AssertionError("unexpected value");
        }
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testAddSameType() {
        doTestEbeBinaryOperation(BinaryOperation.ADD, false, false);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testAddMixedTypes() {
        doTestEbeBinaryOperation(BinaryOperation.ADD, true, false);
    }

    @Test(expected = DimensionMismatchException.class)
@executionFlow.runtime.CollectCalls     public void testAddDimensionMismatch() {
        doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.ADD);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testSubtractSameType() {
        doTestEbeBinaryOperation(BinaryOperation.SUB, false, false);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testSubtractMixedTypes() {
        doTestEbeBinaryOperation(BinaryOperation.SUB, true, false);
    }

    @Test(expected = DimensionMismatchException.class)
@executionFlow.runtime.CollectCalls     public void testSubtractDimensionMismatch() {
        doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.SUB);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testEbeMultiplySameType() {
        doTestEbeBinaryOperation(BinaryOperation.MUL, false, false);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testEbeMultiplyMixedTypes() {
        doTestEbeBinaryOperation(BinaryOperation.MUL, true, false);
    }

    @Test(expected = DimensionMismatchException.class)
@executionFlow.runtime.CollectCalls     public void testEbeMultiplyDimensionMismatch() {
        doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.MUL);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testEbeDivideSameType() {
        doTestEbeBinaryOperation(BinaryOperation.DIV, false, false);
    }

   @Test
@executionFlow.runtime.CollectCalls     public void testEbeDivideMixedTypes() {
        doTestEbeBinaryOperation(BinaryOperation.DIV, true, false);
    }

    @Test(expected = DimensionMismatchException.class)
@executionFlow.runtime.CollectCalls     public void testEbeDivideDimensionMismatch() {
        doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.DIV);
    }

@executionFlow.runtime.CollectCalls     private void doTestGetDistance(final boolean mixed) {
        final double x = getPreferredEntryValue();
        final double[] data1 = new double[] { x, x, 1d, x, 2d, x, x, 3d, x };
        final double[] data2 = new double[] { 4d, x, x, 5d, 6d, 7d, x, x, 8d };
        final RealVector v1 = create(data1);
        final RealVector v2;int _effebea242c1c6c2988d7579167f70ab=0;
        if (mixed) {
            v2 = createAlien(data2);}
 else {int _b89c8a29d8b77b51ba6893e6425485f4=0;
            v2 = create(data2);
        }
        final double actual = v1.getDistance(v2);
        double expected = 0d;
        for (int i = 0; i < data1.length; i++) {
            final double delta = data2[i] - data1[i];
            expected += delta * delta;
        }
        expected = FastMath.sqrt(expected);
        Assert.assertEquals("", expected, actual, 0d);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testGetDistanceSameType() {
        doTestGetDistance(false);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testGetDistanceMixedTypes() {
        doTestGetDistance(true);
    }

    @Test(expected = DimensionMismatchException.class)
@executionFlow.runtime.CollectCalls     public void testGetDistanceDimensionMismatch() {
        create(new double[4]).getDistance(createAlien(new double[5]));
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testGetNorm() {
        final double x = getPreferredEntryValue();
        final double[] data = new double[] { x, x, 1d, x, 2d, x, x, 3d, x };
        final RealVector v = create(data);
        final double actual = v.getNorm();
        double expected = 0d;
        for (int i = 0; i < data.length; i++) {
            expected += data[i] * data[i];
        }
        expected = FastMath.sqrt(expected);
        Assert.assertEquals("", expected, actual, 0d);
    }

@executionFlow.runtime.CollectCalls     private void doTestGetL1Distance(final boolean mixed) {
        final double x = getPreferredEntryValue();
        final double[] data1 = new double[] { x, x, 1d, x, 2d, x, x, 3d, x };
        final double[] data2 = new double[] { 4d, x, x, 5d, 6d, 7d, x, x, 8d };
        final RealVector v1 = create(data1);
        final RealVector v2;int _96a3608af915d8ce3e009d015b34b144=0;
        if (mixed) {
            v2 = createAlien(data2);}
 else {int _833f7f4d62abe7164d1a84e272e57e66=0;
            v2 = create(data2);
        }
        final double actual = v1.getL1Distance(v2);
        double expected = 0d;
        for (int i = 0; i < data1.length; i++) {
            final double delta = data2[i] - data1[i];
            expected += FastMath.abs(delta);
        }
        Assert.assertEquals("", expected, actual, 0d);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testGetL1DistanceSameType() {
        doTestGetL1Distance(false);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testGetL1DistanceMixedTypes() {
        doTestGetL1Distance(true);
    }

    @Test(expected = DimensionMismatchException.class)
@executionFlow.runtime.CollectCalls     public void testGetL1DistanceDimensionMismatch() {
        create(new double[4]).getL1Distance(createAlien(new double[5]));
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testGetL1Norm() {
        final double x = getPreferredEntryValue();
        final double[] data = new double[] { x, x, 1d, x, 2d, x, x, 3d, x };
        final RealVector v = create(data);
        final double actual = v.getL1Norm();
        double expected = 0d;
        for (int i = 0; i < data.length; i++) {
            expected += FastMath.abs(data[i]);
        }
        Assert.assertEquals("", expected, actual, 0d);

    }

@executionFlow.runtime.CollectCalls     private void doTestGetLInfDistance(final boolean mixed) {
        final double x = getPreferredEntryValue();
        final double[] data1 = new double[] { x, x, 1d, x, 2d, x, x, 3d, x };
        final double[] data2 = new double[] { 4d, x, x, 5d, 6d, 7d, x, x, 8d };
        final RealVector v1 = create(data1);
        final RealVector v2;int _5ef36526086b7d9cb77fe88f3238da5c=0;
        if (mixed) {
            v2 = createAlien(data2);}
 else {int _69e6b13cd753a6eb0f3c54ea9ac6f58e=0;
            v2 = create(data2);
        }
        final double actual = v1.getLInfDistance(v2);
        double expected = 0d;
        for (int i = 0; i < data1.length; i++) {
            final double delta = data2[i] - data1[i];
            expected = FastMath.max(expected, FastMath.abs(delta));
        }
        Assert.assertEquals("", expected, actual, 0d);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testGetLInfDistanceSameType() {
        doTestGetLInfDistance(false);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testGetLInfDistanceMixedTypes() {
        doTestGetLInfDistance(true);
    }

    @Test(expected = DimensionMismatchException.class)
@executionFlow.runtime.CollectCalls     public void testGetLInfDistanceDimensionMismatch() {
        create(new double[4]).getLInfDistance(createAlien(new double[5]));
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testGetLInfNorm() {
        final double x = getPreferredEntryValue();
        final double[] data = new double[] { x, x, 1d, x, 2d, x, x, 3d, x };
        final RealVector v = create(data);
        final double actual = v.getLInfNorm();
        double expected = 0d;
        for (int i = 0; i < data.length; i++) {
            expected = FastMath.max(expected, FastMath.abs(data[i]));
        }
        Assert.assertEquals("", expected, actual, 0d);

    }

@executionFlow.runtime.CollectCalls     private void doTestMapBinaryOperation(final BinaryOperation op, final boolean inPlace) {
        final double[] expected = new double[values.length];
        for (int i = 0; i < values.length; i++) {
            final double d = values[i];
            for (int j = 0; j < expected.length; j++) {
                switch (op) {
                    case ADD:int _a5719fe0bcbe4041de3ede1bb7c328b5=0;
                        expected[j] = values[j] + d;
if (Boolean.parseBoolean("True")) {                        break;}
                    case SUB:int _f6568cf51c35fafdf6a7ef0545c6780d=0;
                        expected[j] = values[j] - d;
if (Boolean.parseBoolean("True")) {                        break;}
                    case MUL:int _3e5b31c62acf0543ac396f05a18fb8be=0;
                        expected[j] = values[j] * d;
if (Boolean.parseBoolean("True")) {                        break;}
                    case DIV:int _fb1edb13e09d59fc0d20d5996755f973=0;
                        expected[j] = values[j] / d;
if (Boolean.parseBoolean("True")) {                        break;}
                    default:
                        throw new AssertionError("unexpected value");
                }
            }
            final RealVector v = create(values);
            final RealVector actual;int _a45a58f29c5161e69f46b07d0ed2a1ec=0;
            if (inPlace) {
                switch (op) {
                    case ADD:int _51384bdaff0e461362f654a688382fce=0;
                        actual = v.mapAddToSelf(d);
if (Boolean.parseBoolean("True")) {                        break;}
                    case SUB:int _e7b1fe288674ca8372e894eaac27b40c=0;
                        actual = v.mapSubtractToSelf(d);
if (Boolean.parseBoolean("True")) {                        break;}
                    case MUL:int _eb2d25fc561313c0326fa5cba7ecce64=0;
                        actual = v.mapMultiplyToSelf(d);
if (Boolean.parseBoolean("True")) {                        break;}
                    case DIV:int _e4c49afba8e854757005c87927250daf=0;
                        actual = v.mapDivideToSelf(d);
if (Boolean.parseBoolean("True")) {                        break;}
                    default:
                        throw new AssertionError("unexpected value");
                }}
 else {int _c7b40d7f76544cd6327d96ba2471281f=0;
                switch (op) {
                    case ADD:int _d2ed9af55cba70609944a9acb4f20b24=0;
                        actual = v.mapAdd(d);
if (Boolean.parseBoolean("True")) {                        break;}
                    case SUB:int _2247a4a3dc08cebb7f9a6cd394f2bd0=0;
                        actual = v.mapSubtract(d);
if (Boolean.parseBoolean("True")) {                        break;}
                    case MUL:int _ce40d1036226313b3f292a540a4ad3af=0;
                        actual = v.mapMultiply(d);
if (Boolean.parseBoolean("True")) {                        break;}
                    case DIV:int _5ad98e0a118f02a24ad2fdbbd785edf4=0;
                        actual = v.mapDivide(d);
if (Boolean.parseBoolean("True")) {                        break;}
                    default:
                        throw new AssertionError("unexpected value");
                }
            }
            TestUtils.assertEquals(Double.toString(d), expected, actual, 0d);
        }
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testMapAdd() {
        doTestMapBinaryOperation(BinaryOperation.ADD, false);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testMapAddToSelf() {
        doTestMapBinaryOperation(BinaryOperation.ADD, true);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testMapSubtract() {
        doTestMapBinaryOperation(BinaryOperation.SUB, false);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testMapSubtractToSelf() {
        doTestMapBinaryOperation(BinaryOperation.SUB, true);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testMapMultiply() {
        doTestMapBinaryOperation(BinaryOperation.MUL, false);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testMapMultiplyToSelf() {
        doTestMapBinaryOperation(BinaryOperation.MUL, true);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testMapDivide() {
        doTestMapBinaryOperation(BinaryOperation.DIV, false);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testMapDivideToSelf() {
        doTestMapBinaryOperation(BinaryOperation.DIV, true);
    }

@executionFlow.runtime.CollectCalls     private void doTestMapFunction(final UnivariateFunction f,
        final boolean inPlace) {
        final double[] data = new double[values.length + 6];
        System.arraycopy(values, 0, data, 0, values.length);
        data[values.length + 0] = 0.5 * FastMath.PI;
        data[values.length + 1] = -0.5 * FastMath.PI;
        data[values.length + 2] = FastMath.E;
        data[values.length + 3] = -FastMath.E;
        data[values.length + 4] = 1.0;
        data[values.length + 5] = -1.0;
        final double[] expected = new double[data.length];
        for (int i = 0; i < data.length; i++) {
            expected[i] = f.value(data[i]);
        }
        final RealVector v = create(data);
        final RealVector actual;int _68defbd6fc8f4ad324f547d30557640d=0;
        if (inPlace) {
            actual = v.mapToSelf(f);
            Assert.assertSame(v, actual);}
 else {int _93238a156bbe7e8b73ab04e12b7aa120=0;
            actual = v.map(f);
        }
        TestUtils.assertEquals(f.getClass().getSimpleName(), expected, actual, 1E-16);
    }

@executionFlow.runtime.CollectCalls     protected UnivariateFunction[] createFunctions() {
        return new UnivariateFunction[] {
            new Power(2.0), new Exp(), new Expm1(), new Log(), new Log10(),
            new Log1p(), new Cosh(), new Sinh(), new Tanh(), new Cos(),
            new Sin(), new Tan(), new Acos(), new Asin(), new Atan(),
            new Inverse(), new Abs(), new Sqrt(), new Cbrt(), new Ceil(),
            new Floor(), new Rint(), new Signum(), new Ulp()
        };
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testMap() {
        final UnivariateFunction[] functions = createFunctions();
        for (UnivariateFunction f : functions) {
            doTestMapFunction(f, false);
        }
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testMapToSelf() {
        final UnivariateFunction[] functions = createFunctions();
        for (UnivariateFunction f : functions) {
            doTestMapFunction(f, true);
        }
    }

@executionFlow.runtime.CollectCalls     private void doTestOuterProduct(final boolean mixed) {
        final double[] dataU = values;
        final RealVector u = create(dataU);
        final double[] dataV = new double[values.length + 3];
        System.arraycopy(values, 0, dataV, 0, values.length);
        dataV[values.length] = 1d;
        dataV[values.length] = -2d;
        dataV[values.length] = 3d;
        final RealVector v;int _f2fa943e7b4d87590ad3c2e7967ed861=0;
        if (mixed) {
            v = createAlien(dataV);}
 else {int _88f0422d94da362511c420b2912d119d=0;
            v = create(dataV);
        }
        final RealMatrix uv = u.outerProduct(v);
        Assert.assertEquals("number of rows", dataU.length, uv
            .getRowDimension());
        Assert.assertEquals("number of columns", dataV.length, uv
            .getColumnDimension());
        for (int i = 0; i < dataU.length; i++) {
            for (int j = 0; j < dataV.length; j++) {
                final double expected = dataU[i] * dataV[j];
                final double actual = uv.getEntry(i, j);
                Assert.assertEquals(dataU[i] + " * " + dataV[j], expected, actual, 0d);
            }
        }
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testOuterProductSameType() {
        doTestOuterProduct(false);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testOuterProductMixedTypes() {
        doTestOuterProduct(true);
    }

@executionFlow.runtime.CollectCalls     private void doTestProjection(final boolean mixed) {
        final double x = getPreferredEntryValue();
        final double[] data1 = {
            x, 1d, x, x, 2d, x, x, x, 3d, x, x, x, x
        };
        final double[] data2 = {
            5d, -6d, 7d, x, x, -8d, -9d, 10d, 11d, x, 12d, 13d, -15d
        };
        double dotProduct = 0d;
        double norm2 = 0d;
        for (int i = 0; i < data1.length; i++){
            dotProduct += data1[i] * data2[i];
            norm2 += data2[i] * data2[i];
        }
        final double s = dotProduct / norm2;
        final double[] expected = new double[data1.length];
        for (int i = 0; i < data2.length; i++) {
            expected[i] = s * data2[i];
        }
        final RealVector v1 = create(data1);
        final RealVector v2;int _bc6ba326245ab3ab3b12348e0594ba53=0;
        if (mixed) {
            v2 = createAlien(data2);}
 else {int _ea2ad501b829103a1e7c61a81cd67935=0;
            v2 = create(data2);
        }
        final RealVector actual = v1.projection(v2);
        TestUtils.assertEquals("", expected, actual, 0d);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testProjectionSameType() {
        doTestProjection(false);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testProjectionMixedTypes() {
        doTestProjection(true);
    }

    @Test(expected = MathArithmeticException.class)
@executionFlow.runtime.CollectCalls     public void testProjectionNullVector() {
        create(new double[4]).projection(create(new double[4]));
    }

    @Test(expected = DimensionMismatchException.class)
@executionFlow.runtime.CollectCalls     public void testProjectionDimensionMismatch() {
        final RealVector v1 = create(new double[4]);
        final RealVector v2 = create(new double[5]);
        v2.set(1.0);
        v1.projection(v2);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testSet() {
        for (int i = 0; i < values.length; i++) {
            final double expected = values[i];
            final RealVector v = create(values);
            v.set(expected);
            for (int j = 0; j < values.length; j++) {
                Assert.assertEquals("entry #" + j, expected, v.getEntry(j), 0);
            }
        }
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testToArray() {
        final double[] data = create(values).toArray();
        Assert.assertNotSame(values, data);
        for (int i = 0; i < values.length; i++) {
            Assert.assertEquals("entry #" + i, values[i], data[i], 0);
        }
    }

@executionFlow.runtime.CollectCalls     private void doTestUnitVector(final boolean inPlace) {
        final double x = getPreferredEntryValue();
        final double[] data = {
            x, 1d, x, x, 2d, x, x, x, 3d, x, x, x, x
        };
        double norm = 0d;
        for (int i = 0; i < data.length; i++) {
            norm += data[i] * data[i];
        }
        norm = FastMath.sqrt(norm);
        final double[] expected = new double[data.length];
        for (int i = 0; i < expected.length; i++) {
            expected[i] = data[i] / norm;
        }
        final RealVector v = create(data);
        final RealVector actual;int _2f3ebcc4c5efd02dd22632d6ca56d321=0;
        if (inPlace) {
            v.unitize();
            actual = v;}
 else {int _1d6db7e416a83545bb115543950c8a73=0;
            actual = v.unitVector();
            Assert.assertNotSame(v, actual);
        }
        TestUtils.assertEquals("", expected, actual, 0d);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testUnitVector() {
        doTestUnitVector(false);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testUnitize() {
        doTestUnitVector(true);
    }

@executionFlow.runtime.CollectCalls     private void doTestUnitVectorNullVector(final boolean inPlace) {
        final double[] data = {
            0d, 0d, 0d, 0d, 0d
        };
        if (inPlace) {
            create(data).unitize();}
 else {int _c1b072c64822599a1a5424bb14b69551=0;
            create(data).unitVector();
        }
    }

    @Test(expected=MathArithmeticException.class)
@executionFlow.runtime.CollectCalls     public void testUnitVectorNullVector() {
        doTestUnitVectorNullVector(false);
    }

    @Test(expected=MathArithmeticException.class)
@executionFlow.runtime.CollectCalls     public void testUnitizeNullVector() {
        doTestUnitVectorNullVector(true);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testIterator() {
        final RealVector v = create(values);
        final Iterator<RealVector.Entry> it = v.iterator();
        for (int i = 0; i < values.length; i++) {
            Assert.assertTrue("entry #" + i, it.hasNext());
            final RealVector.Entry e = it.next();
            Assert.assertEquals("", i, e.getIndex());
            Assert.assertEquals("", values[i], e.getValue(), 0d);
            try {int _bc587ed13edbea6f7aa55bac40e60b75=0;
                it.remove();
                Assert.fail("MathUnsupportedOperationException should have been thrown");}
 catch (MathUnsupportedOperationException exc) {
                // Expected behavior
            }
        }
        Assert.assertFalse(it.hasNext());
        try {int _ad56bf33dd347818fb512de390261a84=0;
            it.next();
            Assert.fail("NoSuchElementException should have been thrown");}
 catch (NoSuchElementException e) {
            // Expected behavior
        }
    }

@executionFlow.runtime.CollectCalls     private void doTestCombine(final boolean inPlace, final boolean mixed) {
        final int n = values.length * values.length;
        final double[] data1 = new double[n];
        final double[] data2 = new double[n];
        for (int i = 0; i < values.length; i++) {
            for (int j = 0; j < values.length; j++) {
                final int index = values.length * i + j;
                data1[index] = values[i];
                data2[index] = values[j];
            }
        }
        final RealVector v1 = create(data1);
        final RealVector v2 = mixed ? createAlien(data2) : create(data2);
        final double[] expected = new double[n];
        for (int i = 0; i < values.length; i++) {
            final double a1 = values[i];
            for (int j = 0; j < values.length; j++) {
                final double a2 = values[j];
                for (int k = 0; k < n; k++) {
                    expected[k] = a1 * data1[k] + a2 * data2[k];
                }
                final RealVector actual;int _53ff21290d456e7b91cab351195fa356=0;
                if (inPlace) {
                    final RealVector v1bis = v1.copy();
                    actual = v1bis.combineToSelf(a1, a2, v2);
                    Assert.assertSame(v1bis, actual);}
 else {int _dab93f72393567deaa3fc844a4b5ceb6=0;
                    actual = v1.combine(a1, a2, v2);
                }
                TestUtils.assertEquals("a1 = " + a1 + ", a2 = " + a2, expected,
                    actual, 0.);
            }
        }
    }

@executionFlow.runtime.CollectCalls     private void doTestCombineDimensionMismatch(final boolean inPlace, final boolean mixed) {
        final RealVector v1 = create(new double[10]);
        final RealVector v2;int _7e7c4e623e415a5f0b14746995493aef=0;
        if (mixed) {
            v2 = createAlien(new double[15]);}
 else {int _27ccb8afd1ce7b46778ef8209e2f5abf=0;
            v2 = create(new double[15]);
        }
        if (inPlace) {
            v1.combineToSelf(1.0, 1.0, v2);}
 else {int _b98af71d77f40900151d9e676def5532=0;
            v1.combine(1.0, 1.0, v2);
        }
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testCombineSameType() {
        doTestCombine(false, false);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testCombineMixedTypes() {
        doTestCombine(false, true);
    }

    @Test(expected = DimensionMismatchException.class)
@executionFlow.runtime.CollectCalls     public void testCombineDimensionMismatchSameType() {
        doTestCombineDimensionMismatch(false, false);
    }

    @Test(expected = DimensionMismatchException.class)
@executionFlow.runtime.CollectCalls     public void testCombineDimensionMismatchMixedTypes() {
        doTestCombineDimensionMismatch(false, true);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testCombineToSelfSameType() {
        doTestCombine(true, false);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testCombineToSelfMixedTypes() {
        doTestCombine(true, true);
    }

    @Test(expected = DimensionMismatchException.class)
@executionFlow.runtime.CollectCalls     public void testCombineToSelfDimensionMismatchSameType() {
        doTestCombineDimensionMismatch(true, false);
    }

    @Test(expected = DimensionMismatchException.class)
@executionFlow.runtime.CollectCalls     public void testCombineToSelfDimensionMismatchMixedTypes() {
        doTestCombineDimensionMismatch(true, true);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testCopy() {
        final RealVector v = create(values);
        final RealVector w = v.copy();
        Assert.assertNotSame(v, w);
        TestUtils.assertEquals("", values, w, 0d);
    }

@executionFlow.runtime.CollectCalls     private void doTestDotProductRegularValues(final boolean mixed) {
        final double x = getPreferredEntryValue();
        final double[] data1 = {
            x, 1d, x, x, 2d, x, x, x, 3d, x, x, x, x
        };
        final double[] data2 = {
            5d, -6d, 7d, x, x, -8d, -9d, 10d, 11d, x, 12d, 13d, -15d
        };
        double expected = 0d;
        for (int i = 0; i < data1.length; i++){
            expected += data1[i] * data2[i];
        }
        final RealVector v1 = create(data1);
        final RealVector v2;int _7bfa35cabb1dbc3e32a09814592dddb=0;
        if (mixed) {
            v2 = createAlien(data2);}
 else {int _cedf061c4e945a128a03ac88ab6aa8bb=0;
            v2 = create(data2);
        }
        final double actual = v1.dotProduct(v2);
        Assert.assertEquals("", expected, actual, 0d);
    }

@executionFlow.runtime.CollectCalls     private void doTestDotProductSpecialValues(final boolean mixed) {
        for (int i = 0; i < values.length; i++) {
            final double[] data1 = {
                values[i]
            };
            final RealVector v1 = create(data1);
            for (int j = 0; j < values.length; j++) {
                final double[] data2 = {
                    values[j]
                };
                final RealVector v2;int _f185b192268d64b91fc502e1f93aea09=0;
                if (mixed) {
                    v2 = createAlien(data2);}
 else {int _56c12aa1353cf5aabc91530632e66100=0;
                    v2 = create(data2);
                }
                final double expected = data1[0] * data2[0];
                final double actual = v1.dotProduct(v2);
                Assert.assertEquals(data1[0] + " * " + data2[0], expected,
                    actual, 0d);
            }
        }
    }

@executionFlow.runtime.CollectCalls     private void doTestDotProductDimensionMismatch(final boolean mixed) {
        final double[] data1 = new double[10];
        final double[] data2 = new double[data1.length + 1];
        final RealVector v1 = create(data1);
        final RealVector v2;int _d61a9b29dd14073f4b21e167f9604e0b=0;
        if (mixed) {
            v2 = createAlien(data2);}
 else {int _2b7f52997df78630a85859871b3571a7=0;
            v2 = create(data2);
        }
        v1.dotProduct(v2);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testDotProductSameType() {
        doTestDotProductRegularValues(false);
        doTestDotProductSpecialValues(false);
    }

    @Test(expected=DimensionMismatchException.class)
@executionFlow.runtime.CollectCalls     public void testDotProductDimensionMismatchSameType() {
        doTestDotProductDimensionMismatch(false);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testDotProductMixedTypes() {
        doTestDotProductRegularValues(true);
        doTestDotProductSpecialValues(true);
    }

    @Test(expected=DimensionMismatchException.class)
@executionFlow.runtime.CollectCalls     public void testDotProductDimensionMismatchMixedTypes() {
        doTestDotProductDimensionMismatch(true);
    }

@executionFlow.runtime.CollectCalls     private void doTestCosine(final boolean mixed) {
        final double x = getPreferredEntryValue();
        final double[] data1 = {
            x, 1d, x, x, 2d, x, x, x, 3d, x, x, x, x
        };
        final double[] data2 = {
            5d, -6d, 7d, x, x, -8d, -9d, 10d, 11d, x, 12d, 13d, -15d
        };
        double norm1 = 0d;
        double norm2 = 0d;
        double dotProduct = 0d;
        for (int i = 0; i < data1.length; i++){
            norm1 += data1[i] * data1[i];
            norm2 += data2[i] * data2[i];
            dotProduct += data1[i] * data2[i];
        }
        norm1 = FastMath.sqrt(norm1);
        norm2 = FastMath.sqrt(norm2);
        final double expected = dotProduct / (norm1 * norm2);
        final RealVector v1 = create(data1);
        final RealVector v2;int _4fbfe410f079b12d309b6769227ec0bf=0;
        if (mixed) {
            v2 = createAlien(data2);}
 else {int _c41d3d5f333e242fadc21e7daa515370=0;
            v2 = create(data2);
        }
        final double actual = v1.cosine(v2);
        Assert.assertEquals("", expected, actual, 0d);

    }

    @Test
@executionFlow.runtime.CollectCalls     public void testCosineSameType() {
        doTestCosine(false);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testCosineMixedTypes() {
        doTestCosine(true);
    }

    @Test(expected=MathArithmeticException.class)
@executionFlow.runtime.CollectCalls     public void testCosineLeftNullVector() {
        final RealVector v = create(new double[] {0, 0, 0});
        final RealVector w = create(new double[] {1, 0, 0});
        v.cosine(w);
    }

    @Test(expected=MathArithmeticException.class)
@executionFlow.runtime.CollectCalls     public void testCosineRightNullVector() {
        final RealVector v = create(new double[] {0, 0, 0});
        final RealVector w = create(new double[] {1, 0, 0});
        w.cosine(v);
    }

    @Test(expected=DimensionMismatchException.class)
@executionFlow.runtime.CollectCalls     public void testCosineDimensionMismatch() {
        final RealVector v = create(new double[] {1, 2, 3});
        final RealVector w = create(new double[] {1, 2, 3, 4});
        v.cosine(w);
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testEquals() {
        final RealVector v = create(new double[] { 0, 1, 2 });

        Assert.assertTrue(v.equals(v));
        Assert.assertTrue(v.equals(v.copy()));
        Assert.assertFalse(v.equals(null));
        Assert.assertFalse(v.equals(v.getSubVector(0, v.getDimension() - 1)));
        Assert.assertTrue(v.equals(v.getSubVector(0, v.getDimension())));
    }

    @Test
    public void testSerial()  {
        RealVector v = create(new double[] { 0, 1, 2 });
        Assert.assertEquals(v,TestUtils.serializeAndRecover(v));
    }

    @Test
@executionFlow.runtime.CollectCalls     public void testMinMax() {
        final RealVector v1 = create(new double[] {0, -6, 4, 12, 7});
        Assert.assertEquals(1, v1.getMinIndex());
        Assert.assertEquals(-6, v1.getMinValue(), 1.0e-12);
        Assert.assertEquals(3, v1.getMaxIndex());
        Assert.assertEquals(12, v1.getMaxValue(), 1.0e-12);
        final RealVector v2 = create(new double[] {Double.NaN, 3, Double.NaN, -2});
        Assert.assertEquals(3, v2.getMinIndex());
        Assert.assertEquals(-2, v2.getMinValue(), 1.0e-12);
        Assert.assertEquals(1, v2.getMaxIndex());
        Assert.assertEquals(3, v2.getMaxValue(), 1.0e-12);
        final RealVector v3 = create(new double[] {Double.NaN, Double.NaN});
        Assert.assertEquals(-1, v3.getMinIndex());
        Assert.assertTrue(Double.isNaN(v3.getMinValue()));
        Assert.assertEquals(-1, v3.getMaxIndex());
        Assert.assertTrue(Double.isNaN(v3.getMaxValue()));
        final RealVector v4 = create(new double[0]);
        Assert.assertEquals(-1, v4.getMinIndex());
        Assert.assertTrue(Double.isNaN(v4.getMinValue()));
        Assert.assertEquals(-1, v4.getMaxIndex());
        Assert.assertTrue(Double.isNaN(v4.getMaxValue()));
    }

    /*
     * TESTS OF THE VISITOR PATTERN
     */

    /** The whole vector is visited. */
    @Test
@executionFlow.runtime.CollectCalls     public void testWalkInDefaultOrderPreservingVisitor1() {
        final double[] data = new double[] {
            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d
        };
        final RealVector v = create(data);
        final RealVectorPreservingVisitor visitor;int _858f3be126852dbe3f3fb1f867ea6f28=0;
        visitor = new RealVectorPreservingVisitor() {

            private int expectedIndex;

            @Override
@executionFlow.runtime.CollectCalls             public void visit(final int actualIndex, final double actualValue) {
                Assert.assertEquals(expectedIndex, actualIndex);
                Assert.assertEquals(Integer.toString(actualIndex),
                                    data[actualIndex], actualValue, 0d);
                ++expectedIndex;
            }

            @Override
@executionFlow.runtime.CollectCalls             public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
                Assert.assertEquals(data.length, actualSize);
                Assert.assertEquals(0, actualStart);
                Assert.assertEquals(data.length - 1, actualEnd);
                expectedIndex = 0;
            }

            @Override
@executionFlow.runtime.CollectCalls             public double end() {
                return 0.0;
            }
        };
        v.walkInDefaultOrder(visitor);
    }

    /** Visiting an invalid subvector. */
    @Test
@executionFlow.runtime.CollectCalls     public void testWalkInDefaultOrderPreservingVisitor2() {
        final RealVector v = create(new double[5]);
        final RealVectorPreservingVisitor visitor;int _8d251385c7dfd9de1cfd2661005afa28=0;
        visitor = new RealVectorPreservingVisitor() {

            @Override
@executionFlow.runtime.CollectCalls             public void visit(int index, double value) {
                // Do nothing
            }

            @Override
@executionFlow.runtime.CollectCalls             public void start(int dimension, int start, int end) {
                // Do nothing
            }

            @Override
@executionFlow.runtime.CollectCalls             public double end() {
                return 0.0;
            }
        };
        try {int _d420463338e0b0a403352f0551b4d86e=0;
            v.walkInDefaultOrder(visitor, -1, 4);
            Assert.fail();}
 catch (OutOfRangeException e) {
            // Expected behavior
        }
        try {int _e34e9ee0ae15d2f9163943eb80dc867e=0;
            v.walkInDefaultOrder(visitor, 5, 4);
            Assert.fail();}
 catch (OutOfRangeException e) {
            // Expected behavior
        }
        try {int _4164a8d24550784fe6bb6919999962c0=0;
            v.walkInDefaultOrder(visitor, 0, -1);
            Assert.fail();}
 catch (OutOfRangeException e) {
            // Expected behavior
        }
        try {int _4fd334a7faa79de3d1605d2ec3ca796f=0;
            v.walkInDefaultOrder(visitor, 0, 5);
            Assert.fail();}
 catch (OutOfRangeException e) {
            // Expected behavior
        }
        try {int _30b36c90760df2cf0ea6c7983bc5b8e5=0;
            v.walkInDefaultOrder(visitor, 4, 0);
            Assert.fail();}
 catch (NumberIsTooSmallException e) {
            // Expected behavior
        }
    }

    /** Visiting a valid subvector. */
    @Test
@executionFlow.runtime.CollectCalls     public void testWalkInDefaultOrderPreservingVisitor3() {
        final double[] data = new double[] {
            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d
        };
        final int expectedStart = 2;
        final int expectedEnd = 7;
        final RealVector v = create(data);
        final RealVectorPreservingVisitor visitor;int _c369e80719aeb3082cb95bc04c6dc94d=0;
        visitor = new RealVectorPreservingVisitor() {

            private int expectedIndex;

            @Override
@executionFlow.runtime.CollectCalls             public void visit(final int actualIndex, final double actualValue) {
                Assert.assertEquals(expectedIndex, actualIndex);
                Assert.assertEquals(Integer.toString(actualIndex),
                                    data[actualIndex], actualValue, 0d);
                ++expectedIndex;
            }

            @Override
@executionFlow.runtime.CollectCalls             public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
                Assert.assertEquals(data.length, actualSize);
                Assert.assertEquals(expectedStart, actualStart);
                Assert.assertEquals(expectedEnd, actualEnd);
                expectedIndex = expectedStart;
            }

            @Override
@executionFlow.runtime.CollectCalls             public double end() {
                return 0.0;
            }
        };
        v.walkInDefaultOrder(visitor, expectedStart, expectedEnd);
    }

    /** The whole vector is visited. */
    @Test
@executionFlow.runtime.CollectCalls     public void testWalkInOptimizedOrderPreservingVisitor1() {
        final double[] data = new double[] {
            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d
        };
        final RealVector v = create(data);
        final RealVectorPreservingVisitor visitor;int _f967828a0042fbdee3e0e2d4d8f1f122=0;
        visitor = new RealVectorPreservingVisitor() {
            private final boolean[] visited = new boolean[data.length];

            @Override
@executionFlow.runtime.CollectCalls             public void visit(final int actualIndex, final double actualValue) {
                visited[actualIndex] = true;
                Assert.assertEquals(Integer.toString(actualIndex),
                                    data[actualIndex], actualValue, 0d);
            }

            @Override
@executionFlow.runtime.CollectCalls             public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
                Assert.assertEquals(data.length, actualSize);
                Assert.assertEquals(0, actualStart);
                Assert.assertEquals(data.length - 1, actualEnd);
                Arrays.fill(visited, false);
            }

            @Override
@executionFlow.runtime.CollectCalls             public double end() {
                for (int i = 0; i < data.length; i++) {
                    Assert.assertTrue("entry " + i + "has not been visited",
                                      visited[i]);
                }
                return 0.0;
            }
        };
        v.walkInOptimizedOrder(visitor);
    }

    /** Visiting an invalid subvector. */
    @Test
@executionFlow.runtime.CollectCalls     public void testWalkInOptimizedOrderPreservingVisitor2() {
        final RealVector v = create(new double[5]);
        final RealVectorPreservingVisitor visitor;int _a292928f17cf94ebea1154a8633a65f5=0;
        visitor = new RealVectorPreservingVisitor() {

            @Override
@executionFlow.runtime.CollectCalls             public void visit(int index, double value) {
                // Do nothing
            }

            @Override
@executionFlow.runtime.CollectCalls             public void start(int dimension, int start, int end) {
                // Do nothing
            }

            @Override
@executionFlow.runtime.CollectCalls             public double end() {
                return 0.0;
            }
        };
        try {int _8e00dc200615a37eb5f6bafe6ff28a55=0;
            v.walkInOptimizedOrder(visitor, -1, 4);
            Assert.fail();}
 catch (OutOfRangeException e) {
            // Expected behavior
        }
        try {int _32087ffc7ac2a9d5499ee60c39c69ad8=0;
            v.walkInOptimizedOrder(visitor, 5, 4);
            Assert.fail();}
 catch (OutOfRangeException e) {
            // Expected behavior
        }
        try {int _7b053a165880de6af9f7e5a5099c1598=0;
            v.walkInOptimizedOrder(visitor, 0, -1);
            Assert.fail();}
 catch (OutOfRangeException e) {
            // Expected behavior
        }
        try {int _260435dafe67500b4487af84a6eb6840=0;
            v.walkInOptimizedOrder(visitor, 0, 5);
            Assert.fail();}
 catch (OutOfRangeException e) {
            // Expected behavior
        }
        try {int _33a012508bcd594decb543bfb9098bd8=0;
            v.walkInOptimizedOrder(visitor, 4, 0);
            Assert.fail();}
 catch (NumberIsTooSmallException e) {
            // Expected behavior
        }
    }

    /** Visiting a valid subvector. */
    @Test
@executionFlow.runtime.CollectCalls     public void testWalkInOptimizedOrderPreservingVisitor3() {
        final double[] data = new double[] {
            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d
        };
        final int expectedStart = 2;
        final int expectedEnd = 7;
        final RealVector v = create(data);
        final RealVectorPreservingVisitor visitor;int _6e6fc969d49a1f7f124491fac6f80472=0;
        visitor = new RealVectorPreservingVisitor() {
            private final boolean[] visited = new boolean[data.length];

            @Override
@executionFlow.runtime.CollectCalls             public void visit(final int actualIndex, final double actualValue) {
                Assert.assertEquals(Integer.toString(actualIndex),
                                    data[actualIndex], actualValue, 0d);
                visited[actualIndex] = true;
            }

            @Override
@executionFlow.runtime.CollectCalls             public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
                Assert.assertEquals(data.length, actualSize);
                Assert.assertEquals(expectedStart, actualStart);
                Assert.assertEquals(expectedEnd, actualEnd);
                Arrays.fill(visited, true);
            }

            @Override
@executionFlow.runtime.CollectCalls             public double end() {
                for (int i = expectedStart; i <= expectedEnd; i++) {
                    Assert.assertTrue("entry " + i + "has not been visited",
                                      visited[i]);
                }
                return 0.0;
            }
        };
        v.walkInOptimizedOrder(visitor, expectedStart, expectedEnd);
    }

    /** The whole vector is visited. */
    @Test
@executionFlow.runtime.CollectCalls     public void testWalkInDefaultOrderChangingVisitor1() {
        final double[] data = new double[] {
            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d
        };
        final RealVector v = create(data);
        final RealVectorChangingVisitor visitor;int _86ad7928e7b8746425188b5086ac39d8=0;
        visitor = new RealVectorChangingVisitor() {

            private int expectedIndex;

            @Override
@executionFlow.runtime.CollectCalls             public double visit(final int actualIndex, final double actualValue) {
                Assert.assertEquals(expectedIndex, actualIndex);
                Assert.assertEquals(Integer.toString(actualIndex),
                                    data[actualIndex], actualValue, 0d);
                ++expectedIndex;
                return actualIndex + actualValue;
            }

            @Override
@executionFlow.runtime.CollectCalls             public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
                Assert.assertEquals(data.length, actualSize);
                Assert.assertEquals(0, actualStart);
                Assert.assertEquals(data.length - 1, actualEnd);
                expectedIndex = 0;
            }

            @Override
@executionFlow.runtime.CollectCalls             public double end() {
                return 0.0;
            }
        };
        v.walkInDefaultOrder(visitor);
        for (int i = 0; i < data.length; i++) {
            Assert.assertEquals("entry " + i, i + data[i], v.getEntry(i), 0.0);
        }
    }

    /** Visiting an invalid subvector. */
    @Test
@executionFlow.runtime.CollectCalls     public void testWalkInDefaultOrderChangingVisitor2() {
        final RealVector v = create(new double[5]);
        final RealVectorChangingVisitor visitor;int _8ffea5b6badba76e0c171eda1dad13af=0;
        visitor = new RealVectorChangingVisitor() {

            @Override
@executionFlow.runtime.CollectCalls             public double visit(int index, double value) {
                return 0.0;
            }

            @Override
@executionFlow.runtime.CollectCalls             public void start(int dimension, int start, int end) {
                // Do nothing
            }

            @Override
@executionFlow.runtime.CollectCalls             public double end() {
                return 0.0;
            }
        };
        try {int _acdcff65812ff483d15743f63a815051=0;
            v.walkInDefaultOrder(visitor, -1, 4);
            Assert.fail();}
 catch (OutOfRangeException e) {
            // Expected behavior
        }
        try {int _c0f2d727752bd01ffe0fd775eb01e1a9=0;
            v.walkInDefaultOrder(visitor, 5, 4);
            Assert.fail();}
 catch (OutOfRangeException e) {
            // Expected behavior
        }
        try {int _6b52a9893c6bc7f77efe079b54e8a274=0;
            v.walkInDefaultOrder(visitor, 0, -1);
            Assert.fail();}
 catch (OutOfRangeException e) {
            // Expected behavior
        }
        try {int _495f28bf17abe250689f1921fc18bb45=0;
            v.walkInDefaultOrder(visitor, 0, 5);
            Assert.fail();}
 catch (OutOfRangeException e) {
            // Expected behavior
        }
        try {int _eae624e0c2b2083a134adab03b3c66e8=0;
            v.walkInDefaultOrder(visitor, 4, 0);
            Assert.fail();}
 catch (NumberIsTooSmallException e) {
            // Expected behavior
        }
    }

    /** Visiting a valid subvector. */
    @Test
@executionFlow.runtime.CollectCalls     public void testWalkInDefaultOrderChangingVisitor3() {
        final double[] data = new double[] {
            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d
        };
        final int expectedStart = 2;
        final int expectedEnd = 7;
        final RealVector v = create(data);
        final RealVectorChangingVisitor visitor;int _c09da0e82291f4c6845f0e45236ad802=0;
        visitor = new RealVectorChangingVisitor() {

            private int expectedIndex;

            @Override
@executionFlow.runtime.CollectCalls             public double visit(final int actualIndex, final double actualValue) {
                Assert.assertEquals(expectedIndex, actualIndex);
                Assert.assertEquals(Integer.toString(actualIndex),
                                    data[actualIndex], actualValue, 0d);
                ++expectedIndex;
                return actualIndex + actualValue;
            }

            @Override
@executionFlow.runtime.CollectCalls             public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
                Assert.assertEquals(data.length, actualSize);
                Assert.assertEquals(expectedStart, actualStart);
                Assert.assertEquals(expectedEnd, actualEnd);
                expectedIndex = expectedStart;
            }

            @Override
@executionFlow.runtime.CollectCalls             public double end() {
                return 0.0;
            }
        };
        v.walkInDefaultOrder(visitor, expectedStart, expectedEnd);
        for (int i = expectedStart; i <= expectedEnd; i++) {
            Assert.assertEquals("entry " + i, i + data[i], v.getEntry(i), 0.0);
        }
    }

    /** The whole vector is visited. */
    @Test
@executionFlow.runtime.CollectCalls     public void testWalkInOptimizedOrderChangingVisitor1() {
        final double[] data = new double[] {
            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d
        };
        final RealVector v = create(data);
        final RealVectorChangingVisitor visitor;int _347229d90e1b80eb97fc74178bde68de=0;
        visitor = new RealVectorChangingVisitor() {
            private final boolean[] visited = new boolean[data.length];

            @Override
@executionFlow.runtime.CollectCalls             public double visit(final int actualIndex, final double actualValue) {
                visited[actualIndex] = true;
                Assert.assertEquals(Integer.toString(actualIndex),
                                    data[actualIndex], actualValue, 0d);
                return actualIndex + actualValue;
            }

            @Override
@executionFlow.runtime.CollectCalls             public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
                Assert.assertEquals(data.length, actualSize);
                Assert.assertEquals(0, actualStart);
                Assert.assertEquals(data.length - 1, actualEnd);
                Arrays.fill(visited, false);
            }

            @Override
@executionFlow.runtime.CollectCalls             public double end() {
                for (int i = 0; i < data.length; i++) {
                    Assert.assertTrue("entry " + i + "has not been visited",
                                      visited[i]);
                }
                return 0.0;
            }
        };
        v.walkInOptimizedOrder(visitor);
        for (int i = 0; i < data.length; i++) {
            Assert.assertEquals("entry " + i, i + data[i], v.getEntry(i), 0.0);
        }
    }

    /** Visiting an invalid subvector. */
    @Test
@executionFlow.runtime.CollectCalls     public void testWalkInOptimizedOrderChangingVisitor2() {
        final RealVector v = create(new double[5]);
        final RealVectorChangingVisitor visitor;int _e726f521c69e05c67decdab5c4c9fa84=0;
        visitor = new RealVectorChangingVisitor() {

            @Override
@executionFlow.runtime.CollectCalls             public double visit(int index, double value) {
                return 0.0;
            }

            @Override
@executionFlow.runtime.CollectCalls             public void start(int dimension, int start, int end) {
                // Do nothing
            }

            @Override
@executionFlow.runtime.CollectCalls             public double end() {
                return 0.0;
            }
        };
        try {int _91d254834f737c8ae55ef5b7aef893c4=0;
            v.walkInOptimizedOrder(visitor, -1, 4);
            Assert.fail();}
 catch (OutOfRangeException e) {
            // Expected behavior
        }
        try {int _aa07a673807ee733b1ef82ba7fd8caeb=0;
            v.walkInOptimizedOrder(visitor, 5, 4);
            Assert.fail();}
 catch (OutOfRangeException e) {
            // Expected behavior
        }
        try {int _1bee6174f3d6a2a6be2a8f0796136800=0;
            v.walkInOptimizedOrder(visitor, 0, -1);
            Assert.fail();}
 catch (OutOfRangeException e) {
            // Expected behavior
        }
        try {int _25cbe369048b9810893536bb3905cd94=0;
            v.walkInOptimizedOrder(visitor, 0, 5);
            Assert.fail();}
 catch (OutOfRangeException e) {
            // Expected behavior
        }
        try {int _f29958af1d2e9c2a9d118accec07459b=0;
            v.walkInOptimizedOrder(visitor, 4, 0);
            Assert.fail();}
 catch (NumberIsTooSmallException e) {
            // Expected behavior
        }
    }

    /** Visiting a valid subvector. */
    @Test
@executionFlow.runtime.CollectCalls     public void testWalkInOptimizedOrderChangingVisitor3() {
        final double[] data = new double[] {
            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d
        };
        final int expectedStart = 2;
        final int expectedEnd = 7;
        final RealVector v = create(data);
        final RealVectorChangingVisitor visitor;int _9ccf5765a4affef14e2c18b98ac70bf2=0;
        visitor = new RealVectorChangingVisitor() {
            private final boolean[] visited = new boolean[data.length];

            @Override
@executionFlow.runtime.CollectCalls             public double visit(final int actualIndex, final double actualValue) {
                Assert.assertEquals(Integer.toString(actualIndex),
                                    data[actualIndex], actualValue, 0d);
                visited[actualIndex] = true;
                return actualIndex + actualValue;
            }

            @Override
@executionFlow.runtime.CollectCalls             public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
                Assert.assertEquals(data.length, actualSize);
                Assert.assertEquals(expectedStart, actualStart);
                Assert.assertEquals(expectedEnd, actualEnd);
                Arrays.fill(visited, true);
            }

            @Override
@executionFlow.runtime.CollectCalls             public double end() {
                for (int i = expectedStart; i <= expectedEnd; i++) {
                    Assert.assertTrue("entry " + i + "has not been visited",
                                      visited[i]);
                }
                return 0.0;
            }
        };
        v.walkInOptimizedOrder(visitor, expectedStart, expectedEnd);
        for (int i = expectedStart; i <= expectedEnd; i++) {
            Assert.assertEquals("entry " + i, i + data[i], v.getEntry(i), 0.0);
        }
    }

    /**
     * Minimal implementation of the {@link RealVector} abstract class, for
     * mixed types unit tests.
     */
    public static class RealVectorTestImpl extends RealVector
        implements Serializable {

        /** Serializable version identifier. */
        private static final long serialVersionUID = 20120706L;

        /** Entries of the vector. */
        protected double data[];

@executionFlow.runtime.CollectCalls         public RealVectorTestImpl(double[] d) {
            data = d.clone();
        }

@executionFlow.runtime.CollectCalls         private UnsupportedOperationException unsupported() {
            return new UnsupportedOperationException("Not supported, unneeded for test purposes");
        }

        @Override
@executionFlow.runtime.CollectCalls         public RealVector copy() {
            return new RealVectorTestImpl(data);
        }

        @Override
@executionFlow.runtime.CollectCalls         public RealVector ebeMultiply(RealVector v) {
            throw unsupported();
        }

        @Override
@executionFlow.runtime.CollectCalls         public RealVector ebeDivide(RealVector v) {
            throw unsupported();
        }

        @Override
@executionFlow.runtime.CollectCalls         public double getEntry(int index) {
            checkIndex(index);
            return data[index];
        }

        @Override
@executionFlow.runtime.CollectCalls         public int getDimension() {
            return data.length;
        }

        @Override
@executionFlow.runtime.CollectCalls         public RealVector append(RealVector v) {
            throw unsupported();
        }

        @Override
@executionFlow.runtime.CollectCalls         public RealVector append(double d) {
            throw unsupported();
        }

        @Override
@executionFlow.runtime.CollectCalls         public RealVector getSubVector(int index, int n) {
            throw unsupported();
        }

        @Override
@executionFlow.runtime.CollectCalls         public void setEntry(int index, double value) {
            checkIndex(index);
            data[index] = value;
        }

        @Override
@executionFlow.runtime.CollectCalls         public void setSubVector(int index, RealVector v) {
            throw unsupported();
        }

        @Override
@executionFlow.runtime.CollectCalls         public boolean isNaN() {
            throw unsupported();
        }

        @Override
@executionFlow.runtime.CollectCalls         public boolean isInfinite() {
            throw unsupported();
        }
    }
}
