package executionFlow.io.preprocessor;

import java.io.IOException;
import java.nio.file.Path;
import java.util.List;

import executionFlow.io.FileEncoding;
import executionFlow.io.preprocessor.testmethod.AnnotationProcessor;
import executionFlow.io.preprocessor.testmethod.AssertProcessor;
import executionFlow.io.preprocessor.testmethod.TestMethodHighlighter;
import executionFlow.io.processor.FileProcessor;
import executionFlow.util.FileUtil;
import executionFlow.util.logger.LogLevel;
import executionFlow.util.logger.Logger;


/**
 * Responsible for pre-processing test method file. Handles exceptions
 * generated by asserts and converts JUnit 5 tests to JUnit 4 tests.
 * 
 * @author		William Niemiec &lt; williamniemiec@hotmail.com &gt;
 * @version		5.2.3
 * @since		2.0.0
 */
public class PreTestMethodFileProcessor extends FileProcessor
{
	//-------------------------------------------------------------------------
	//		Attributes
	//-------------------------------------------------------------------------
	private static final long serialVersionUID = 400L;

	private String testMethodSignature;
	private Object[] testMethodArgs;
	private static int totalTests;
		
	
	//-------------------------------------------------------------------------
	//		Constructor
	//-------------------------------------------------------------------------
	/**
	 * Handles exceptions generated by asserts. Specifically, adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Also, converts tests JUnit 5 to JUnit 4.
	 * 
	 * @param		file Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Processed file name
	 * @param		testMethodSignature Test method signature
	 * @param		testMethodArgs Test method arguments (for parameterized tests)
	 * @param		fileExtension Output file extension (without dot)
	 * (default is java)
	 * @param		encode File encoding
	 */ 
	private PreTestMethodFileProcessor(Path file, Path outputDir, 
			String outputFilename, String testMethodSignature, 
			Object[] testMethodArgs, String fileExtension, FileEncoding encode)
	{
		this.file = file;
		this.outputFilename = outputFilename;
		this.testMethodArgs = testMethodArgs;
		this.testMethodSignature = testMethodSignature;
		
		if (outputDir != null)
			outputFile = outputDir.resolve(outputFilename + "." + fileExtension);
		else	
			outputFile = Path.of(outputFilename +  "." + fileExtension);
		
		if (encode != null)
			this.encode = encode;
	}
	
	
	//-------------------------------------------------------------------------
	//		Builder
	//-------------------------------------------------------------------------
	/**
	 * Builder for {@link PreTestMethodFileProcessor}. It is necessary to
	 * provide all required fields. The required fields are: <br />
	 * <ul>
	 * 	<li>file</li>
	 * 	<li>outputDir</li>
	 * 	<li>outputFilename</li>
	 * 	<li>testMethodSignature</li>
	 * </ul>
	 */
	public static class Builder
	{
		private FileEncoding encode;
		private String fileExtension = "java";
		private Path file;
		private Path outputDir;
		private String outputFilename;
		private String testMethodSignature;
		private Object[] testMethodArgs;

		
		/**
		 * @param		file Path of the file to be parsed
		 * 
		 * @return		Itself to allow chained calls
		 * 
		 * @throws		IllegalArgumentException If file is null
		 */
		public Builder file(Path file)
		{
			if (file == null)
				throw new IllegalArgumentException("File cannot be null");
			
			this.file = file;
			
			return this;
		}
		
		/**
		 * @param		outputDir Directory where parsed file will be saved
		 * 
		 * @return		Itself to allow chained calls
		 * 
		 * @throws		IllegalArgumentException If Output directory is null
		 */
		public Builder outputDir(Path outputDir)
		{
			if (outputDir == null)
				throw new IllegalArgumentException("Output directory cannot be null");
			
			this.outputDir = outputDir;
			
			return this;
		}
		
		/**
		 * @param		outputFilename Processed file name
		 * 
		 * @return		Itself to allow chained calls
		 * 
		 * @throws		IllegalArgumentException If output filename is null
		 */
		public Builder outputFilename(String outputFilename)
		{
			if (outputFilename == null)
				throw new IllegalArgumentException("Output filename cannot be null");
			
			this.outputFilename = outputFilename;
			
			return this;
		}
		
		/**
		 * @param		encode File encoding (default is UTF-8)
		 * 
		 * @return		Itself to allow chained calls
		 */
		public Builder encode(FileEncoding encode)
		{
			if (encode != null)
				this.encode = encode;
			
			return this;
		}
		
		/**
		 * @param		testMethodSignature Test method signature
		 * 
		 * @return		Itself to allow chained calls
		 * 
		 * @throws		IllegalArgumentException If test method signature is null
		 */
		public Builder testMethodSignature(String testMethodSignature)
		{
			if (testMethodSignature == null)
				throw new IllegalArgumentException("Test method signature cannot be null");
			
			this.testMethodSignature = testMethodSignature;
			return this;
		}
		
		/**
		 * @param		testMethodArgs Test method arguments (for parameterized
		 * tests)
		 * 
		 * @return		Itself to allow chained calls
		 */
		public Builder testMethodArgs(Object... testMethodArgs)
		{
			this.testMethodArgs = testMethodArgs;
			
			return this;
		}
		
		/**
		 * @param		fileExtension Output file extension (without dot)
		 * (default is java)
		 * 
		 * @return		Itself to allow chained calls
		 */
		public Builder fileExtension(String fileExtension)
		{
			if (fileExtension != null)
				this.fileExtension = fileExtension;
			
			return this;
		}
		
		/**
		 * Creates {@link PreTestMethodFileProcessor} with provided information.
		 * It is necessary to provide all required fields. The required fields 
		 * are: <br />
		 * <ul>
		 * 	<li>file</li>
		 * 	<li>outputDir</li>
		 * 	<li>outputFilename</li>
		 * 	<li>testMethodSignature</li>
		 * </ul>
		 * 
		 * @return		PreTestMethodFileProcessor with provided information
		 * 
		 * @throws		IllegalArgumentException If any required field is null
		 */
		public PreTestMethodFileProcessor build()
		{
			StringBuilder nullFields = new StringBuilder();
			
			if (file == null)
				nullFields.append("file").append(", ");
			if (outputDir == null)
				nullFields.append("outputDir").append(", ");
			if (outputFilename == null)
				nullFields.append("outputFilename").append(", ");
			if (testMethodSignature == null)
				nullFields.append("testMethodSignature").append(", ");
			
			if (nullFields.length() > 0)
				throw new IllegalArgumentException("Required fields cannot be null: "
						+ nullFields.substring(0, nullFields.length()-2));	// Removes last comma
			
			return new PreTestMethodFileProcessor(
					file, outputDir, outputFilename, testMethodSignature, 
					testMethodArgs, fileExtension, encode
			);
		}
	}
	
	
	//-------------------------------------------------------------------------
	//		Methods
	//-------------------------------------------------------------------------	
	/**
	 * Adds a try-catch structure for each assert, so that execution does not 
	 * stop even if an assert fails.
	 * 
	 * @return		Path to parsed file
	 * 
	 * @throws		IOException If file encoding is incorrect or if file cannot
	 * be read / written
	 * 
	 * @implNote	Catch will be {@link Throwable}
	 */
	@Override
	public String processFile() throws IOException
	{
		if (file == null)
			return "";
		
		List<String> lines = FileUtil.getLines(file, encode.getStandardCharset());
		
		lines = doProcessing(lines);
		
		dump(lines);
		
		FileUtil.putLines(lines, outputFile, encode.getStandardCharset());
		
		return outputFile.toString();
	}

	private List<String> doProcessing(List<String> lines) {
		List<String> processedLines;
		
		TestMethodHighlighter testMethodHighlighter = new TestMethodHighlighter(testMethodSignature);
		processedLines = testMethodHighlighter.processLines(lines);
		
		AssertProcessor assertProcessor = new AssertProcessor();
		processedLines = assertProcessor.processLines(processedLines);
		
		AnnotationProcessor annotationProcessor = new AnnotationProcessor(testMethodArgs);
		processedLines = annotationProcessor.processLines(processedLines);
		totalTests = annotationProcessor.getTotalTests();
		
		return processedLines;
	}

	private void dump(List<String> lines) {
		if (Logger.getLevel() != LogLevel.DEBUG)
			return;
		
		Logger.debug("PreTestMethodFileProcessor", "Processed file");
		FileUtil.printFileWithLines(lines);
	}
	
	public static int getTotalTests() {
		return totalTests;
	}
}
