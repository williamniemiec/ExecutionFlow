package executionFlow.io.processor;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import executionFlow.io.FileEncoding;
import executionFlow.runtime.collector.CollectorExecutionFlow;
import executionFlow.util.Logger;
import executionFlow.util.DataUtil;
import executionFlow.util.FileUtil;
import executionFlow.util.balance.CurlyBracketBalance;


/**
 * Responsible for pre-processing test method file. Handles exceptions
 * generated by asserts and converts JUnit 5 tests to JUnit 4 tests.
 * 
 * @author		William Niemiec &lt; williamniemiec@hotmail.com &gt;
 * @version		5.2.1
 * @since		2.0.0
 */
public class PreTestMethodFileProcessor extends FileProcessor
{
	//-------------------------------------------------------------------------
	//		Attributes
	//-------------------------------------------------------------------------
	private static final long serialVersionUID = 400L;
		
	private static int totalIgnored;
	private int currentLine;
	private String fileExtension = "java";
	private String testMethodSignature;
	private Object[] testMethodArgs;
	private String paramEnumType;
	private boolean insideMultilineComment;
		
	
	//-------------------------------------------------------------------------
	//		Constructor
	//-------------------------------------------------------------------------
	/**
	 * Handles exceptions generated by asserts. Specifically, adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Also, converts tests JUnit 5 to JUnit 4. Using this
	 * constructor, encode will be UTF 8.
	 * 
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Processed file name
	 * @param		testMethodSignature Test method signature
	 * @param		testMethodArgs Test method arguments (for parameterized tests)
	 * @param		fileExtension Output file extension (without dot)
	 * (default is java)
	 */ 
	private PreTestMethodFileProcessor(Path file, Path outputDir, 
			String outputFilename, String testMethodSignature, 
			Object[] testMethodArgs, String fileExtension)
	{
		this.file = file;
		this.outputDir = outputDir;
		this.outputFilename = outputFilename;
		this.testMethodSignature = testMethodSignature;
		this.testMethodArgs = testMethodArgs;
		this.fileExtension = fileExtension;
	}
	
	/**
	 * Handles exceptions generated by asserts. Specifically, adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Also, converts tests JUnit 5 to JUnit 4.
	 * 
	 * @param		file Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Processed file name
	 * @param		testMethodSignature Test method signature
	 * @param		testMethodArgs Test method arguments (for parameterized tests)
	 * @param		fileExtension Output file extension (without dot)
	 * (default is java)
	 * @param		encode File encoding
	 */ 
	private PreTestMethodFileProcessor(Path file, Path outputDir, 
			String outputFilename, String testMethodSignature, 
			Object[] testMethodArgs, String fileExtension, FileEncoding encode)
	{
		this(file, outputDir, outputFilename, testMethodSignature, 
				testMethodArgs, fileExtension);
		this.encode = encode;
	}
	
	
	//-------------------------------------------------------------------------
	//		Builder
	//-------------------------------------------------------------------------
	/**
	 * Builder for {@link PreTestMethodFileProcessor}. It is necessary to
	 * provide all required fields. The required fields are: <br />
	 * <ul>
	 * 	<li>file</li>
	 * 	<li>outputDir</li>
	 * 	<li>outputFilename</li>
	 * 	<li>testMethodSignature</li>
	 * </ul>
	 */
	public static class Builder
	{
		private FileEncoding encode;
		private String fileExtension = "java";
		private Path file;
		private Path outputDir;
		private String outputFilename;
		private String testMethodSignature;
		private Object[] testMethodArgs;

		
		/**
		 * @param		file Path of the file to be parsed
		 * 
		 * @return		Itself to allow chained calls
		 * 
		 * @throws		IllegalArgumentException If file is null
		 */
		public Builder file(Path file)
		{
			if (file == null)
				throw new IllegalArgumentException("File cannot be null");
			
			this.file = file;
			
			return this;
		}
		
		/**
		 * @param		outputDir Directory where parsed file will be saved
		 * 
		 * @return		Itself to allow chained calls
		 * 
		 * @throws		IllegalArgumentException If Output directory is null
		 */
		public Builder outputDir(Path outputDir)
		{
			if (outputDir == null)
				throw new IllegalArgumentException("Output directory cannot be null");
			
			this.outputDir = outputDir;
			
			return this;
		}
		
		/**
		 * @param		outputFilename Processed file name
		 * 
		 * @return		Itself to allow chained calls
		 * 
		 * @throws		IllegalArgumentException If output filename is null
		 */
		public Builder outputFilename(String outputFilename)
		{
			if (outputFilename == null)
				throw new IllegalArgumentException("Output filename cannot be null");
			
			this.outputFilename = outputFilename;
			
			return this;
		}
		
		/**
		 * @param		encode File encoding (default is UTF-8)
		 * 
		 * @return		Itself to allow chained calls
		 */
		public Builder encode(FileEncoding encode)
		{
			if (encode != null)
				this.encode = encode;
			
			return this;
		}
		
		/**
		 * @param		testMethodSignature Test method signature
		 * 
		 * @return		Itself to allow chained calls
		 * 
		 * @throws		IllegalArgumentException If test method signature is null
		 */
		public Builder testMethodSignature(String testMethodSignature)
		{
			if (testMethodSignature == null)
				throw new IllegalArgumentException("Test method signature cannot be null");
			
			this.testMethodSignature = testMethodSignature;
			return this;
		}
		
		/**
		 * @param		testMethodArgs Test method arguments (for parameterized
		 * tests)
		 * 
		 * @return		Itself to allow chained calls
		 */
		public Builder testMethodArgs(Object... testMethodArgs)
		{
			this.testMethodArgs = testMethodArgs;
			
			return this;
		}
		
		/**
		 * @param		fileExtension Output file extension (without dot)
		 * (default is java)
		 * 
		 * @return		Itself to allow chained calls
		 */
		public Builder fileExtension(String fileExtension)
		{
			if (fileExtension != null)
				this.fileExtension = fileExtension;
			
			return this;
		}
		
		/**
		 * Creates {@link PreTestMethodFileProcessor} with provided information.
		 * It is necessary to provide all required fields. The required fields 
		 * are: <br />
		 * <ul>
		 * 	<li>file</li>
		 * 	<li>outputDir</li>
		 * 	<li>outputFilename</li>
		 * 	<li>testMethodSignature</li>
		 * </ul>
		 * 
		 * @return		PreTestMethodFileProcessor with provided information
		 * 
		 * @throws		IllegalArgumentException If any required field is null
		 */
		public PreTestMethodFileProcessor build()
		{
			StringBuilder nullFields = new StringBuilder();
			
			
			if (file == null)
				nullFields.append("file").append(", ");
			if (outputDir == null)
				nullFields.append("outputDir").append(", ");
			if (outputFilename == null)
				nullFields.append("outputFilename").append(", ");
			if (testMethodSignature == null)
				nullFields.append("testMethodSignature").append(", ");
			
			if (nullFields.length() > 0)
				throw new IllegalArgumentException("Required fields cannot be null: "
						+ nullFields.substring(0, nullFields.length()-2));	// Removes last comma
			
			return	encode == null ? 
					new PreTestMethodFileProcessor(file, outputDir, outputFilename,
							testMethodSignature, testMethodArgs, fileExtension) : 
					new PreTestMethodFileProcessor(file, outputDir, outputFilename, 
							testMethodSignature, testMethodArgs, fileExtension, encode);
		}
	}
	
	
	//-------------------------------------------------------------------------
	//		Methods
	//-------------------------------------------------------------------------	
	/**
	 * Adds a try-catch structure for each assert, so that execution does not 
	 * stop even if an assert fails.
	 * 
	 * @return		Path to parsed file
	 * 
	 * @throws		IOException If file encoding is incorrect or if file cannot
	 * be read / written
	 * 
	 * @implNote	Catch will be {@link Throwable}
	 */
	@Override
	public String processFile() throws IOException
	{
		if (file == null)
			return "";

		final String REGEX_COMMENT_FULL_LINE = 
				"^(\\t|\\ )*(\\/\\/|\\/\\*|\\*\\/|\\*).*";
		String line;
		int totLines;
		File outputFile;
		List<Integer> ignoredMethods;
		List<String> lines;
		AssertParser assertParser = new AssertParser();
		AnnotationParser annotationParser = testMethodArgs == null ? 
				new AnnotationParser(testMethodSignature) : 
				new AnnotationParser(testMethodSignature, testMethodArgs);

		
		// If an output directory is specified, processed file will be saved to it
		if (outputDir != null)
			outputFile = new File(outputDir.toFile(), outputFilename + "." + fileExtension);
		else	// Else processed file will be saved in current directory
			outputFile = new File(outputFilename +  "." + fileExtension);
		
		currentLine = 1;
		
		lines = FileUtil.getLines(file, encode.getStandardCharset());
		totLines = lines.size();
		
		// Parses file line by line
		for (int i=0; i<totLines; i++) {
			line = lines.get(i);
			
			// Checks if it is multiline comment
			if (line.contains("/*") && !line.contains("*/")) {
				insideMultilineComment = true;
			}
			else if (insideMultilineComment) {
				if (line.contains("*/"))
					insideMultilineComment = false;
			}
			else {
				// Process the line
				if (!line.matches(REGEX_COMMENT_FULL_LINE)  && !insideMultilineComment) {
					line = assertParser.parse(line);
					line = annotationParser.parse(line);
				}
					
				lines.set(i, line);
			}
			
			currentLine++;
		}
		
		ignoredMethods = annotationParser.getIgnoredMethods();
		totalIgnored = ignoredMethods.size();
		
		// Comments test annotations and method declaration from all tests
		// except the test method provided
		if (!ignoredMethods.isEmpty()) {
			boolean insideMethod = false;
			
			
			currentLine--;
			
			for (int i=totLines-1; i>=0; i--) {
				line = lines.get(i);
				
				if (insideMethod) {
					if (!line.contains("@"))
						insideMethod = false;
					else
						line = "//" + line;		
				}
				else if (ignoredMethods.contains(currentLine)) {
					line = "//" + line;
					insideMethod = true;
				}
				
				lines.set(i, line);
				currentLine--;
			}
		}
		
		// -----{ DEBUG }-----
		if (Logger.getLevel() == Logger.Level.DEBUG) {
			Logger.debug("PreTestMethodFileProcessor", "Processed file");
			FileUtil.printFileWithLines(lines);
		}
		// -----{ END DEBUG }-----
		
		FileUtil.putLines(lines, outputFile.toPath(), encode.getStandardCharset());
		
		return outputFile.getAbsolutePath();
	}
	
	
	//-------------------------------------------------------------------------
	//		Getters
	//-------------------------------------------------------------------------
	/**
	 * Gets total of ignored test methods. A test method is ignored if it is 
	 * different from the one passed in the constructor.
	 * 
	 * @return		Total of ignored methods
	 * 
	 * @implNote	Should be called after processing the file 
	 * (method: {@link #processFile()})
	 */
	public static int getTotalIgnoredMethods()
	{
		return totalIgnored;
	}
	
	
	//-------------------------------------------------------------------------
	//		Inner classes
	//-------------------------------------------------------------------------
	/**
	 * Responsible for disabling collectors in a test method and converting
	 * JUnit 5 test annotation to JUnit 4 test annotation.
	 * 
	 * @author		William Niemiec &lt; williamniemiec@hotmail.com &gt;
	 * @version		5.2.1
	 * @since 		2.0.0
	 */
	private class AnnotationParser
	{
		//---------------------------------------------------------------------
		//		Attributes
		//---------------------------------------------------------------------
		private static final String REGEX_METHOD_DECLARATION = 
				"^.*[\\s\\t]+((?!new)[A-z0-9\\_\\<\\>\\,\\[\\]\\.\\$])+[\\s\\t]+([A-z0-9\\_\\$]+)[\\s\\t]*\\(.*\\).*$";
		private static final String REGEX_REPEATED_TEST = 
				".*@(.*\\.)?RepeatedTest(\\ |\\t)*\\(.+\\)(\\ |\\t)*";
		private static final String REGEX_JUNIT4_TEST = 
				".*@(.*\\.)?(org\\.junit\\.)?Test(\\ |\\t)*(\\ |\\t)*(\\(.*\\))?";
		private static final String REGEX_PARAMETERIZED_TEST = 
				".*@(.*\\.)?(org\\.junit\\.jupiter\\.params\\.)?ParameterizedTest(\\ |\\t)*(\\ |\\t)*";
		private String numRepetitions;
		private String testMethodSignature;
		private String[] testMethodParams;
		private Object[] testMethodArgs;
		private CurlyBracketBalance curlyBracketBalance_currentTestMethod;
		private CurlyBracketBalance curlyBracketBalance_ignore;
		private CurlyBracketBalance curlyBracketBalance_repeatedTest;
		private CurlyBracketBalance curlyBracketBalance_parameterizedTest;
		private boolean inTestMethodSignature;
		private boolean repeatedTest_putLoop;
		private boolean insideRepeatedTest;
		private boolean ignoreMethod;
		private boolean inTestAnnotationScope;
		private boolean isSelectedTestMethod;

		/**
		 * Stores test method declaration lines that are not part of the test 
		 * method provided in the constructor.
		 */
		private List<Integer> ignoredMethods = new ArrayList<>();
		
		
		//---------------------------------------------------------------------
		//		Constructor
		//---------------------------------------------------------------------
		/**
		 * Responsible for disabling collectors in a test method and converting
		 * JUnit 5 test annotation to JUnit 4 test annotation. 
		 * 
		 * @param		testMethodSignature Test method signature
		 * @param		testMethodArgs Test method arguments (for parameterized
		 * tests)
		 */
		public AnnotationParser(String testMethodSignature, Object[] testMethodArgs)
		{
			this(testMethodSignature);
			this.testMethodArgs = testMethodArgs;
		}
		
		/**
		 * Responsible for disabling collectors in a test method and converting
		 * JUnit 5 test annotation to JUnit 4 test annotation. Use this
		 * constructor if test method is not a parameterized test.
		 * 
		 * @param		testMethodSignature Test method signature
		 */
		public AnnotationParser(String testMethodSignature)
		{ 
			this.testMethodSignature = CollectorExecutionFlow.extractMethodName(testMethodSignature) + 
					testMethodSignature.substring(testMethodSignature.indexOf("(")).replace(" ", "");
		}
		
		
		//---------------------------------------------------------------------
		//		Methods
		//---------------------------------------------------------------------
		/**
		 * Processes a line disabling collectors in a test method and converting
		 * JUnit 5 test annotation to JUnit 4 test annotation.
		 * 
		 * @param		line Line to be parsed
		 * 
		 * @return		Processed line
		 */
		public String parse(String line)
		{
			if (line.contains("@") && !inTestAnnotationScope) {
				inTestAnnotationScope =	line.matches(REGEX_JUNIT4_TEST) || 
										line.matches(REGEX_REPEATED_TEST) || 
										line.matches(REGEX_PARAMETERIZED_TEST) || 
										line.contains("@org.junit.jupiter.api.Test");
			}

			if (inTestAnnotationScope) {System.out.println("testScop");
				if (curlyBracketBalance_currentTestMethod != null) {
					curlyBracketBalance_currentTestMethod.parse(line);
				}
				else if (line.matches(REGEX_METHOD_DECLARATION) ) {//&& 
					curlyBracketBalance_currentTestMethod = new CurlyBracketBalance();
					curlyBracketBalance_currentTestMethod.parse(line);
					isSelectedTestMethod = extractMethodSignatureFromLine(line).replace(" ", "").equals(testMethodSignature);
				}
			
				if (curlyBracketBalance_currentTestMethod != null) {
					if (!isSelectedTestMethod) { 
						line = parseIgnore(line);
					}
					
					if (curlyBracketBalance_currentTestMethod.isBalanceEmpty()) {
						curlyBracketBalance_currentTestMethod = null;
						inTestAnnotationScope = false;
						isSelectedTestMethod = false;
					}
				}
			}
			
			if (!ignoreMethod) {
				line = parseInsideRepeatedTest(line);
				
				// Converts test annotation from JUnit 5 to JUnit 4
				line = parseAnnotations(line);
			}
			
			return line;
		}
		
		/**
		 * Parses test annotations. It will convert JUnit 5 annotations to 
		 * JUnit 4 test annotation ({@link org.junit.Test}).
		 * 
		 * @param		line Current source file line
		 * 
		 * @return		Processed line
		 */
		private String parseAnnotations(String line)
		{
			return	line.matches(REGEX_JUNIT4_TEST) 			 ?	parseTestAnnotation(line, false) :
					line.contains("@org.junit.jupiter.api.Test") ?	parseTestAnnotation(line, true) :
					line.matches(REGEX_REPEATED_TEST) 			 ?	parseRepeatedTest(line) :
					line.matches(REGEX_PARAMETERIZED_TEST) || 
								 testMethodArgs != null			 ?	parseParameterizedTest(line) : 
					line;
		}
		
		/**
		 * Checks whether current source file line should be ignored. If yes,
		 * comments the entire line. It will be ignored methods other than the 
		 * provided test method ({@link #testMethodSignature}).
		 * 
		 * @param		line Current source file line
		 * 
		 * @return		Processed line (it will be commented if it should be 
		 * ignored)
		 * 
		 * @implNote	Only the body of the methods will be commented, 
		 * requiring a second scan of the file to comment on the 
		 * declaration of the methods as well as their annotations.
		 */
		private String parseIgnore(String line)
		{			
			// If it is inside a method that should be ignored, comment its code
			if (ignoreMethod) {
				if (curlyBracketBalance_ignore == null)
					curlyBracketBalance_ignore = new CurlyBracketBalance();
				
				curlyBracketBalance_ignore.parse(line);
				
				ignoreMethod = !curlyBracketBalance_ignore.isBalanceEmpty();

				line = "//" + line;
			}
			
			// If current method it is not the given test method, ignores it		
			else if (line.matches(REGEX_METHOD_DECLARATION) && !line.contains("private ") && 
					!extractMethodSignatureFromLine(line).replace(" ", "").equals(testMethodSignature)) {
				if (curlyBracketBalance_ignore == null)
					curlyBracketBalance_ignore = new CurlyBracketBalance();
				
				curlyBracketBalance_ignore.parse(line);
				inTestMethodSignature = false;
				ignoreMethod = true;
				ignoredMethods.add(currentLine);
			}
			
			return line;
		}
		
		/**
		 * Gets method signature from a source file line;
		 * 
		 * @param		line Source file line
		 * 
		 * @return		Method signature
		 */
		private String extractMethodSignatureFromLine(String line)
		{
			StringBuilder methodParams = new StringBuilder();
			String methodName = line.substring(
					line.substring(0, line.indexOf("(")).lastIndexOf(" "), 
					line.lastIndexOf("(")
			);
			String methodParamsAndArgs = line.substring(line.indexOf("(")+1, line.lastIndexOf(")"));
			String response;
			
			
			if (methodParamsAndArgs.isBlank()) {
				response = methodName + "()";
			}
			else {
				for (String param : methodParamsAndArgs.split(",")) {
					methodParams.append(param.trim().split(" ")[0]);
					methodParams.append(",");
				}
				
				if (methodParams.length() > 1) {
					methodParams.deleteCharAt(methodParams.length()-1);
				}
				
				response = methodName + "(" + methodParams.toString() + ")";
			}
			
			return response;
		}
		
		/**
		 * Checks whether it is inside a method with 
		 * {@link org.junit.jupiter.api.RepeatedTest}. If it is, converts it to
		 * {@link org.junit.Test} using while control flow instead.
		 * 
		 * @param		line Current source file line
		 * 
		 * @return		If is is inside a repeated test, while control flow 
		 * resulting from the conversion of 
		 * {@link org.junit.jupiter.api.RepeatedTest} to {@link org.junit.Test};
		 * otherwise, returns the same line
		 */
		private String parseInsideRepeatedTest(String line)
		{
			// Converts repeated test to while test
			if (repeatedTest_putLoop) {
				if (line.contains("{")) {
					repeatedTest_putLoop = false;
					line = repeatedTest_putWhileLoop(line);
					
					curlyBracketBalance_repeatedTest = new CurlyBracketBalance();
					curlyBracketBalance_repeatedTest.parse(line);
					curlyBracketBalance_repeatedTest.decreaseBalance();
				}
			}
			// Checks if it is the end of repeated test
			else if (insideRepeatedTest && curlyBracketBalance_repeatedTest != null && line.contains("}")) {
				curlyBracketBalance_repeatedTest.parse(line);
				
				if (curlyBracketBalance_repeatedTest.isBalanceEmpty()) {
					int idx = line.lastIndexOf("}");
					
					
					insideRepeatedTest = false;
					curlyBracketBalance_repeatedTest = null;
					
					line = line.substring(0, idx+1) + "}" + line.substring(idx+1);
				}
			}
			
			return line;
		}
		
		/**
		 * Converts JUnit 5 test to JUnit 4 test (converts 
		 * {@link org.junit.jupiter.api.Test} to {@link org.junit.Test}. Also,
		 * converts '@Test' to '@org.junit.Test'.
		 * 
		 * @param		line Current source file line
		 * @param		isJunit5 Indicates if current source file line belongs
		 * to a JUnit 5 test.
		 * 
		 * @return		Processed line		
		 */
		private String parseTestAnnotation(String line, boolean isJunit5)
		{
			return	isJunit5 ? 
						line.replace("@org.junit.jupiter.api.Test", "@org.junit.Test") : 
						line.replace("@Test", "@org.junit.Test");
	}	
		
		/**
		 * Converts {@link org.junit.jupiter.api.RepeatedTest} to 
		 * {@link org.junit.Test}.
		 * 
		 * @param		line Current source file line
		 * 
		 * @return		Processed line
		 */
		private String parseRepeatedTest(String line)
		{
			Pattern p = Pattern.compile(REGEX_REPEATED_TEST);
			Matcher m = p.matcher(line);
			
			
			numRepetitions = "0";
			insideRepeatedTest = true;
			
			if (m.find()) {
				String repeatedTestAnnotation = m.group();
				
				
				line = line.replace(repeatedTestAnnotation, "@org.junit.Test");

				// Gets number of repetitions
				m = Pattern.compile("\\(.*\\)").matcher(repeatedTestAnnotation);
				
				if (m.find()) {
					String annotationParams = m.group().replace("(", "").replace(")", "");
					
					
					if (annotationParams.contains("value")) {
						m = Pattern.compile("[0-9]+").matcher(annotationParams);
						
						if (m.find())
							numRepetitions = m.group();
					}
					else {
						numRepetitions = annotationParams;						
					}
				}
			}
			
			repeatedTest_putLoop = true;
			
			return line;
		}
		
		/**
		 * Converts {@link org.junit.jupiter.params.ParameterizedTest} to 
		 * {@link org.junit.Test}.
		 * 
		 * @param		line Current source file line
		 * 
		 * @return		Processed line
		 */
		@SuppressWarnings("rawtypes")
		private String parseParameterizedTest(String line)
		{
			if (curlyBracketBalance_parameterizedTest == null)
				curlyBracketBalance_parameterizedTest = new CurlyBracketBalance();
			
			// Converts JUnit 5 parameterized test to JUnit 4 test
			if (line.contains("@ParameterizedTest")) {
				line = line.replace("@ParameterizedTest", "@org.junit.Test");
				inTestMethodSignature = true;

			}
			// Gets enum type
			else if (line.contains("@EnumSource")) {
				Matcher m = Pattern.compile("(\\ |\\t)*value(\\ |\\t)*=").matcher(line);
				
				
				// EnumSource with value attribute 
				if (m.find()) {
					paramEnumType = line.split(m.group())[1].split("\\.")[0].trim();
				}
				// EnumSource without value attribute but with class specified
				else if (line.contains("(")) {
					paramEnumType = line.substring(line.indexOf("(")+1, line.indexOf(")")).split("\\.")[0].trim();
				}
				// Empty EnumSource 
				else {
					paramEnumType = "";
				}
			}
			// Checks if it is within parameterized test
			else if (inTestMethodSignature) {
				// Converts test method parameters to local variables 
				if (line.matches(REGEX_METHOD_DECLARATION)) {
					if (!extractMethodSignatureFromLine(line).replace(" ", "").equals(testMethodSignature)) {
						inTestMethodSignature = false;
						curlyBracketBalance_parameterizedTest.parse(line);
						ignoreMethod = true;
					}
					else {
						// Extracts parameters
						Matcher m = Pattern.compile("\\(.*\\)").matcher(line);
						String params;
						
						
						if (m.find()) {
							params = m.group().replace("(", "").replace(")", "");
							testMethodParams = params.split(","); // Removes parentheses
							line = line.replace(params, ""); // Deletes params from method
						}
					}
				}
				// Converts parameters to local variables
				else if (testMethodParams != null && !line.contains("@")) {
					StringBuilder localVars = new StringBuilder();
					
					
					// Converts each parameter with its value into a local variable
					for (int i=0; i<testMethodParams.length; i++) {
						testMethodParams[i] = testMethodParams[i].trim();
						
						// Checks if parameterized test contains 'EnumSource' annotation
						if (paramEnumType != null) {
							
							// Checks if parameterized test contains 'EnumType' annotation without arguments
							if (paramEnumType.isEmpty())
								testMethodArgs[i] = testMethodParams[i] + "." + ((Enum)testMethodArgs[i]).name();
							else
								testMethodArgs[i] = paramEnumType + "." + ((Enum)testMethodArgs[i]).name();
						}
						
						localVars.append(testMethodParams[i] + "=");
						
						if (testMethodArgs[i] == null)
							localVars.append("null");
						else if (testMethodParams[i].contains("String "))
							localVars.append("\"" 
									+ ((String)testMethodArgs[i])
									.replace("\n", "\\n")
									.replace("\t", "\\t")
									.replace("\r", "\\r") + "\""
							);
						else
							localVars.append(testMethodArgs[i]);
						
						localVars.append(";");
					}
					
					// Puts converted parameters on the source file line
					if (line.contains("{")) {
						int index = line.indexOf("{");
						
						
						line = line.substring(0, index+1) + localVars + line.substring(index+1);
					}
					else {
						line = localVars + line;
					}

					inTestMethodSignature = false;
				}
			}
			
			return line;
		}
					
		/**
		 * Converts repeated test to a while loop.
		 * 
		 * @param		line Line to be placed the while clause
		 * 
		 * @return		Line with while clause along with the function arguments
		 */
		private String repeatedTest_putWhileLoop(String line)
		{
			int idx = line.lastIndexOf("{");
			String varname = DataUtil.generateVarName();
			
			
			return line.substring(0, idx + 1) + "int "+ varname + "=0;while(" +
				varname + "++ < " + numRepetitions + "){" + line.substring(idx + 1);
		}
		
		
		//---------------------------------------------------------------------
		//		Getters
		//---------------------------------------------------------------------
		/**
		 * Gest test method declaration lines that are not part of the test 
		 * method provided in the constructor.
		 * 
		 * @return		Test method declaration lines
		 */
		public List<Integer> getIgnoredMethods()
		{
			return ignoredMethods;
		}
	}
	
	/**
	 * Adds try-catch to all asserts so that test method execution does not
	 * stop if an assert fails.
	 * 
	 * @author		William Niemiec &lt; williamniemiec@hotmail.com &gt;
	 * @version		4.0.0
	 * @since 		2.0.0
	 */
	private class AssertParser
	{
		//---------------------------------------------------------------------
		//		Attributes
		//---------------------------------------------------------------------
		private final Pattern PATTERN_ASSERT = 
				Pattern.compile("^(\\ |\\t)+(Assert\\.)?assert[A-z]+(\\ |\\t)*\\((.+\\);)?");
		private String try_catch_message = "", catchType = "Throwable";
		private int endOfAssert;
		private int commentStart;
		private int roundBracketsBalance = 0;
		private boolean inAssert;
		
		
		//---------------------------------------------------------------------
		//		Methods
		//---------------------------------------------------------------------
		/**
		 * Processes a line adding try-catch to asserts so that test method
		 * execution does not stop if an assert fails.
		 * 
		 * @param		line Line to be parsed
		 * 
		 * @return		Processed line
		 */
		public String parse(String line)
		{
			int lastCurlyBracketInSameLine = line.lastIndexOf("}");
			String varname = DataUtil.generateVarName();
			
			
			// Checks if it is within a multiline assert
			if (inAssert) {
				roundBracketsBalance += getRoundBracketsBalance(line);
				
				if (roundBracketsBalance == 0) {
					inAssert = false;
					endOfAssert = line.lastIndexOf(';') + 1;
					
					if (lastCurlyBracketInSameLine != -1) {
						line = line.substring(0, lastCurlyBracketInSameLine) 
							+ "} catch(" + catchType + " " + varname + "){" + try_catch_message + "}"
							+ line.substring(lastCurlyBracketInSameLine);
					}
					else {
						line = line.substring(0, endOfAssert) 
							+ "} catch(" + catchType + " " + varname + "){" + try_catch_message + "}"
							+ line.substring(endOfAssert);
					}
				}					
			}
			// Checks if it is an assert instruction
			else if (PATTERN_ASSERT.matcher(line).find()) {
				roundBracketsBalance = getRoundBracketsBalance(line);
				
				// Checks if it is an inline assert
				if (roundBracketsBalance == 0) {
					// Checks if it is a comment next to the line
					commentStart = line.indexOf("//");
					
					if (commentStart == -1)
						commentStart = line.indexOf("*/");
					
					// There is no comment next to the line
					if (commentStart == -1)
						if (lastCurlyBracketInSameLine != -1) {
							line = "try {" + line.substring(0, lastCurlyBracketInSameLine) + "} "
								+ "catch(" + catchType + " " + varname + "){" + try_catch_message + "}}";
						}
						else {
							line = "try {" + line + "} "
								+ "catch(" + catchType + " " + varname + "){" + try_catch_message + "}";
						}
					// There is a comment next to the line
					else {
						if (lastCurlyBracketInSameLine != -1) {
							line = "try {" + line.substring(0, lastCurlyBracketInSameLine)
							+ "} catch(" + catchType + " " + varname + "){" + try_catch_message + "}"
							+ line.substring(commentStart);
						}
						else {
							line = "try {" + line.substring(0, commentStart)
								+ "} catch(" + catchType + " " + varname + "){" + try_catch_message + "}"
								+ line.substring(commentStart);
						}
					}
				}
				// Multi-line assert
				else {
					inAssert = true;
					line = "try {" + line;
				}
			}
			
			return line;
		}
		
		/**
		 * Gets amount of '(' minus amount of ')' in a line.
		 * 
		 * @param		line Line to be analyzed
		 * 
		 * @return		Amount of '(' minus amount of ')' in the line
		 */
		private int getRoundBracketsBalance(String line)
		{
			return (int) (
				line.chars()
					.filter(c -> c == '(')
					.count() - 
				line.chars()
					.filter(c -> c == ')')
					.count()
			);
		}
	}
}
