package executionFlow.io.processor;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import executionFlow.io.FileEncoding;
import executionFlow.runtime.collector.CollectorExecutionFlow;
import executionFlow.util.ConsoleOutput;
import executionFlow.util.CurlyBracketBalance;
import executionFlow.util.DataUtils;


/**
 * Responsible for pre-processing test method file. Handles exceptions
 * generated by asserts and converts JUnit 5 tests to JUnit 4 tests.
 * 
 * @author		William Niemiec &lt; williamniemiec@hotmail.com &gt;
 * @version		2.1.0
 * @since		2.0.0
 */
public class PreTestMethodFileProcessor extends FileProcessor
{
	//-------------------------------------------------------------------------
	//		Attributes
	//-------------------------------------------------------------------------
	private static final long serialVersionUID = 200L;
	
	/**
	 * If true, displays processed lines.
	 */
	private static final boolean DEBUG;
	
	private String fileExtension = "java";
	
	
	private String testMethodSignature;
	private Object testMethodArg;
	private int currentLine;
	private final String regex_methodDeclaration = 
			"(\\ |\\t)*([A-z0-9\\-_$<>\\[\\]\\ \\t]+(\\s|\\t))+[A-z0-9\\-_$]+"
			+ "\\(([A-z0-9\\-_$,<>\\[\\]\\ \\t])*\\)(\\{|(\\s\\{)||\\/)*(\\ |\\t)*";
	
	private static int totalAnnotations;
	
	
	
	//-------------------------------------------------------------------------
	//		Initialization blocks
	//-------------------------------------------------------------------------
	/**
	 * Configures environment. If {@link #DEBUG} is true, displays processed 
	 * lines.
	 */
	static {
		DEBUG = false;
	}
	
	
	//-------------------------------------------------------------------------
	//		Constructor
	//-------------------------------------------------------------------------
	/**
	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Also, converts tests JUnit 5 to JUnit 4. Using this 
	 * constructor, file encoding will be UTF-8.
	 * 
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Name of the parsed file
	 */ 
	public PreTestMethodFileProcessor(Path filepath, Path outputDir, String outputFilename)
	{
		this.file = filepath;
		this.outputDir = outputDir;
		this.outputFilename = outputFilename;
	}
	
	/**
	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Also, converts tests JUnit 5 to JUnit 4. Using this 
	 * constructor, file encoding will be UTF-8.
	 * 
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Name of the parsed file
	 * @param		fileExtension Output file extension (without dot)
	 * (default is java)
	 */ 
	public PreTestMethodFileProcessor(Path filepath, Path outputDir, String outputFilename, String fileExtension)
	{
		this(filepath, outputDir, outputFilename);
		this.fileExtension = fileExtension;
	}
	
	
	
	
	
//	/**
//	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
//	 * structure for each assert, so that execution does not stop even if an 
//	 * assert fails. Also, converts tests JUnit 5 to JUnit 4. Using this 
//	 * constructor, file encoding will be UTF-8.
//	 * 
//	 * @param		filename Path of the file to be parsed
//	 * @param		outputDir Directory where parsed file will be saved
//	 * @param		outputFilename Name of the parsed file
//	 * @param		fileExtension Output file extension (without dot)
//	 * (default is java)
//	 * @param		testMethodArg Test method argument (for parameterized tests)
//	 */ 
//	public PreTestMethodFileProcessor(Path filepath, Path outputDir, String outputFilename, 
//			String fileExtension, Object testMethodArg)
//	{
//		this(filepath, outputDir, outputFilename);
//		this.fileExtension = fileExtension;
//		this.testMethodArg = testMethodArg;
//	}
//	
	
	
	
	
	
	
	
	
	
	/**
	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Also, converts tests JUnit 5 to JUnit 4.
	 * 
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Name of the parsed file
	 * @param		encode File encoding
	 */ 
	public PreTestMethodFileProcessor(Path filepath, Path outputDir, String outputFilename, 
			FileEncoding encode)
	{
		this(filepath, outputDir, outputFilename);
		this.encode = encode;
	}
	

	
	
	
	
	/**
	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Also, converts tests JUnit 5 to JUnit 4. Using this 
	 * constructor, file encoding will be UTF-8.
	 * 
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Name of the parsed file
	 * @param		testMethodArg Test method argument (for parameterized tests)
	 */ 
	public PreTestMethodFileProcessor(Path filepath, Path outputDir, 
			String outputFilename, Object testMethodArg, String testMethodSignature)
	{
		this(filepath, outputDir, outputFilename);
		this.testMethodArg = testMethodArg;
		this.testMethodSignature = testMethodSignature;
	}
	
	
	/**
	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Also, converts tests JUnit 5 to JUnit 4. Using this 
	 * constructor, file encoding will be UTF-8.
	 * 
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Name of the parsed file
	 * @param		testMethodArg Test method argument (for parameterized tests)
	 */ 
	public PreTestMethodFileProcessor(Path filepath, Path outputDir, 
			String outputFilename, Object testMethodArg, String testMethodSignature, String fileExtension)
	{
		this(filepath, outputDir, outputFilename);
		this.testMethodArg = testMethodArg;
		this.testMethodSignature = testMethodSignature;
		this.fileExtension = fileExtension;
	}
	
	
	
	
	/**
	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Also, converts tests JUnit 5 to JUnit 4.
	 * 
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Name of the parsed file
	 * @param		testMethodArg Test method argument (for parameterized tests)
	 * @param		fileExtension Output file extension (without dot)
	 * (default is java)
	 */ 
	public PreTestMethodFileProcessor(Path filepath, Path outputDir, 
			String outputFilename, FileEncoding encode, Object testMethodArg, String testMethodSignature)
	{
		this(filepath, outputDir, outputFilename, testMethodArg, testMethodSignature);
		this.encode = encode;
	}
	
	/**
	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Also, converts tests JUnit 5 to JUnit 4.
	 * 
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Name of the parsed file
	 * @param		testMethodArg Test method argument (for parameterized tests)
	 * @param		fileExtension Output file extension (without dot)
	 * (default is java)
	 */ 
	public PreTestMethodFileProcessor(Path filepath, Path outputDir, 
			String outputFilename, FileEncoding encode, Object testMethodArg, String testMethodSignature,
			String fileExtension)
	{
		this(filepath, outputDir, outputFilename, testMethodArg, testMethodSignature);
		this.encode = encode;
		this.fileExtension = fileExtension;
	}
	
	
	//-------------------------------------------------------------------------
	//		Methods
	//-------------------------------------------------------------------------
	/**
	 * Adds a try-catch structure for each assert, so that execution does not 
	 * stop even if an assert fails.
	 * 
	 * @return		Path to parsed file
	 * 
	 * @throws		IOException If file encoding is incorrect or if file cannot
	 * be read / written
	 * 
	 * @implNote	Catch will be {@link Throwable}
	 */
	@Override
	public String processFile() throws IOException
	{
		if (file == null) { return ""; }

		final String regex_commentFullLine = "^(\\t|\\ )*(\\/\\/|\\/\\*).*";
		String line;
		File outputFile;
		Map<Integer, Boolean> testAnnotations;
		AssertParser assertParser = new AssertParser();
//		AnnotationParser annotationParser = testMethodArg == null ? new AnnotationParser() : 
//			new AnnotationParser(testMethodArg, testMethodSignature);
		AnnotationParser annotationParser = new AnnotationParser(testMethodArg, testMethodSignature);

		
		// If an output directory is specified, processed file will be saved to it
		if (outputDir != null)
			outputFile = new File(outputDir.toFile(), outputFilename + "." + fileExtension);
		else	// Else processed file will be saved in current directory
			outputFile = new File(outputFilename +  "." + fileExtension);
		
		currentLine = 1;
		
		// Opens file streams (file to be parsed and output file / processed file)
		try (BufferedReader br = Files.newBufferedReader(file, encode.getStandardCharset());
			 BufferedWriter bw = Files.newBufferedWriter(outputFile.toPath(), encode.getStandardCharset())) { 
			
			// Parses file line by line
			while ((line = br.readLine()) != null) {
				if (!line.matches(regex_commentFullLine)) {
					line = assertParser.parse(line);
					line = annotationParser.parse(line);
				}
				
				// -----{ DEBUG }-----
				if (DEBUG) { ConsoleOutput.showDebug(line); }
				// -----{ END DEBUG }-----
				
				bw.write(line);
				bw.newLine();
				currentLine++;
			}
		}

		// Removes test annotations from all tests except the test method provided
		testAnnotations = annotationParser.getMarkedAnnotations();
		
		
		totalAnnotations = testAnnotations.size();
		
		
		
		if (!testAnnotations.isEmpty()) {
			Path tmp = Path.of(outputFile.getAbsolutePath()+".tmp");
			boolean insideMethod = false;
			
			
			currentLine = 1;
			
			try (BufferedReader br = Files.newBufferedReader(outputFile.toPath(), encode.getStandardCharset());
				 BufferedWriter bw = Files.newBufferedWriter(tmp, encode.getStandardCharset())) {
				while ((line = br.readLine()) != null) {
					if (insideMethod) {
						if (line.matches(regex_commentFullLine))
							insideMethod = false;
						else
							line = "//" + line;
							
					}
					else if (testAnnotations.containsKey(currentLine) && !testAnnotations.get(currentLine)) {
						line = "//" + line;
						insideMethod = true;
					}
					
					bw.write(line);
					bw.newLine();
					currentLine++;
				}
			}
			
			Files.move(tmp, outputFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
		}
		
		return outputFile.getAbsolutePath();
	}
	
	/**
	 * Gets total test annotation in the file.
	 * 
	 * @return		Total test annotations
	 * 
	 * @implNote	Should be called after processing the file 
	 * (method: {@link #processFile()})
	 */
	public static int getTotalAnnotations()
	{
		return totalAnnotations;
	}
	
	/**
	 * Gets amount of '(' minus amount of ')' in a line.
	 * 
	 * @param		line Line to be analyzed
	 * 
	 * @return		Amount of '(' minus amount of ')' in the line
	 */
	private int getRoundBracketsBalance(String line)
	{
		return (int) (
			line.chars()
				.filter(c -> c == '(')
				.count() - 
			line.chars()
				.filter(c -> c == ')')
				.count()
		);
	}
	
	
	//-------------------------------------------------------------------------
	//		Inner classes
	//-------------------------------------------------------------------------
	/**
	 * Responsible for disabling collectors in a test method and converting
	 * JUnit 5 test annotation to JUnit 4 test annotation.
	 * 
	 * @author		William Niemiec &lt; williamniemiec@hotmail.com &gt;
	 * @version		2.1.0
	 * @since 		2.0.0
	 */
	private class AnnotationParser
	{
		//---------------------------------------------------------------------
		//		Attributes
		//---------------------------------------------------------------------
		private boolean inTestMethodSignature;
		private boolean repeatedTest_putLoop;
		private boolean withinRepeatedTest;
		private boolean ignoreMethod;
		private String parameters = null;
		private String numRepetitions;
		private String testMethodName;
		private Object testMethodArg;
		private CurlyBracketBalance curlyBracketBalance;
		
		/**
		 * Stores all test annotations along with if it belongs to given test
		 * method or not.
		 * 
		 * <ul>
		 * 	<li><b>Key:</b> Source file line</li>
		 * 	<li><b>Value:</b> Flag indicating whether the test annotation 
		 * 	belongs to the test method provided</li>
		 * </ul>
		 */
		private Map<Integer, Boolean> testAnnotationLine = new HashMap<>();
		
		private int lastAnnotationInserted;
		
		
		//---------------------------------------------------------------------
		//		Constructor
		//---------------------------------------------------------------------
		/**
		 * Responsible for disabling collectors in a test method and converting
		 * JUnit 5 test annotation to JUnit 4 test annotation. 
		 * 
		 * @param		testMethodArg Test method argument (for parameterized
		 * tests)
		 * @param		testMethodSignature Test method signature
		 */
		public AnnotationParser(Object testMethodArg, String testMethodSignature)
		{
			this(testMethodSignature);
			this.testMethodArg = testMethodArg == null ? "null" : testMethodArg  ;
		}
		
		/**
		 * Responsible for disabling collectors in a test method and converting
		 * JUnit 5 test annotation to JUnit 4 test annotation. Use this
		 * constructor if test method is not a parameterized test.
		 * 
		 * @param		testMethodSignature Test method signature
		 */
		public AnnotationParser(String testMethodSignature)
		{ 
			this.testMethodName = CollectorExecutionFlow.extractMethodName(testMethodSignature);
		}
		
		
		//---------------------------------------------------------------------
		//		Methods
		//---------------------------------------------------------------------
		/**
		 * Processes a line disabling collectors in a test method and converting
		 * JUnit 5 test annotation to JUnit 4 test annotation.
		 * 
		 * @param		line Line to be parsed
		 * 
		 * @return		Processed line
		 */
		public String parse(String line)
		{
			// If it is inside a method that should be ignored, comment its code
			if (ignoreMethod) {
				if (curlyBracketBalance == null)
					curlyBracketBalance = new CurlyBracketBalance();
				
				curlyBracketBalance.parse(line);
				
				ignoreMethod = !curlyBracketBalance.isBalanceEmpty();
				
				return "//" + line;
			}
			
			// If current method it is not the given test method, ignores it		
			if (line.matches(regex_methodDeclaration) && !line.contains("private") && 
					!line.contains(testMethodName+"(")) {
				inTestMethodSignature = false;
				ignoreMethod = true;
				testAnnotationLine.put(lastAnnotationInserted, false);
				
				return line;
			}
			
			// Converts repeated test to while test
			if (repeatedTest_putLoop) {
				if (line.contains("{")) {
					repeatedTest_putLoop = false;
					line = repeatedTest_toLoop(line);
					
					curlyBracketBalance = new CurlyBracketBalance();
					curlyBracketBalance.parse(line);
					curlyBracketBalance.decreaseBalance();
				}
			}
			
			// Checks if it is the end of repeated test
			else if (withinRepeatedTest && curlyBracketBalance != null && line.contains("}")) {
				curlyBracketBalance.parse(line);
				
				if (curlyBracketBalance.isBalanceEmpty()) {
					int idx = line.lastIndexOf("}");
					
					
					withinRepeatedTest = false;
					curlyBracketBalance = null;
					
					line = line.substring(0, idx+1) + "}" + line.substring(idx+1);
				}
			}
			else {
				// Converts test annotation from JUnit 5 to JUnit 4
				if (line.contains("@Test")) {
					line = line.replace("@Test", "@org.junit.Test");
					testAnnotationLine.put(currentLine, true);
					lastAnnotationInserted = currentLine;
				}
				else if (line.contains("@org.junit.jupiter.api.Test")) {
					line = line.replace("@org.junit.jupiter.api.Test", "@org.junit.Test");
					testAnnotationLine.put(currentLine, true);
					lastAnnotationInserted = currentLine;
				}
				else if (line.contains("@RepeatedTest")) {
					Pattern p = Pattern.compile("@RepeatedTest\\(.*\\)");
					Matcher m = p.matcher(line);
					
					
					numRepetitions = "0";
					withinRepeatedTest = true;
					
					if (m.find()) {
						String repeatedTestAnnotation = m.group();
						line = line.replace(repeatedTestAnnotation, "@org.junit.Test @executionFlow.runtime.isRepeatedTest");
						testAnnotationLine.put(currentLine, true);
						lastAnnotationInserted = currentLine;
						
						// Gets number of repetitions
						m = Pattern.compile("\\(.*\\)").matcher(repeatedTestAnnotation);
						
						if (m.find()) {
							numRepetitions = m.group().replace("(", "").replace(")", "");
						}
					}
					
					repeatedTest_putLoop = true;
				}
				
				// If it is a parameterized test, converts it to a JUnit 4 test
				if (testMethodArg != null) {
					if (curlyBracketBalance == null)
						curlyBracketBalance = new CurlyBracketBalance();
					
					// Converts JUnit 5 parameterized test to JUnit 4 test
					if (line.contains("@ParameterizedTest")) {
						line = line.replace("@ParameterizedTest", "@org.junit.Test");
						inTestMethodSignature = true;
						testAnnotationLine.put(currentLine, true);
						lastAnnotationInserted = currentLine;
					}
					// Checks if it is within parameterized test
					else if (inTestMethodSignature) {
						// Converts test method parameters to local variables 
						if (line.matches(regex_methodDeclaration)) {
							if (!line.contains(testMethodName)) {
								inTestMethodSignature = false;
								curlyBracketBalance.parse(line);
								ignoreMethod = true;
							}
							else {
								// Extracts parameters
								Matcher m = Pattern.compile("\\(.*\\)").matcher(line);
								
								
								if (m.find()) {
									parameters = m.group();
									parameters = parameters.replace("(", "").replace(")", ""); // Removes parentheses
									line = line.replace(parameters, ""); // Deletes params from method
								}
							}
						}
						// Converts parameters to local variables
						else if (parameters != null && !line.contains("@")) {
							if (parameters.contains("String ")) {
								parameters = parameters + "=";
								
								if (testMethodArg.equals("null")) {
									parameters += ((String)testMethodArg).replace("\n", "\\n").replace("\t", "\\t").replace("\r", "\\r");
								}
								else {
									parameters += "\""+ ((String)testMethodArg).replace("\n", "\\n").replace("\t", "\\t").replace("\r", "\\r") + "\"";
								}
								
								parameters += ";";
							}
							else
								parameters = parameters + "=" + testMethodArg  + ";";
							
							if (line.contains("{")) {
								int index = line.indexOf("{");
								
								
								line = line.substring(0, index+1) + parameters + line.substring(index+1);
							}
							else {
								line = parameters + line;
							}
	
							inTestMethodSignature = false;
						}
					}
				}
				
				if (curlyBracketBalance != null && withinRepeatedTest) {
					curlyBracketBalance.parse(line);
				}
			}
			
			return line;
		}
		
		/**
		 * Converts repeated test to a while loop.
		 * 
		 * @param		line Line to be placed the while clause
		 * 
		 * @return		Line with while clause along with the function arguments
		 */
		private String repeatedTest_toLoop(String line)
		{
			int idx = line.lastIndexOf("{");
			String varname = DataUtils.generateVarName();
			
			
			return line.substring(0, idx + 1) + "int "+ varname + "=0;while(" +
				varname + "++ < " + numRepetitions + "){" + line.substring(idx + 1);
		}
		
		
		//---------------------------------------------------------------------
		//		Getters
		//---------------------------------------------------------------------
		/**
		 * Gets test annotations along with a flag indicating whether it 
		 * belongs to the test method provided or not.
		 * 
		 * @return		Line number of test annotations referring to the source
		 * code along with a flag indicating whether it. The returned map has
		 * the following structure: 
		 * <ul>
		 * 	<li><b>Key:</b> Source file line</li>
		 * 	<li><b>Value:</b> Flag indicating whether the test annotation 
		 * 	belongs to the test method provided</li>
		 * </ul>
		 */
		public Map<Integer, Boolean> getMarkedAnnotations()
		{
			return testAnnotationLine;
		}
	}
	
	/**
	 * Adds try-catch to all asserts so that test method execution does not
	 * stop if an assert fails.
	 * 
	 * @author		William Niemiec &lt; williamniemiec@hotmail.com &gt;
	 * @version		2.0.0
	 * @since 		2.0.0
	 */
	private class AssertParser
	{
		//---------------------------------------------------------------------
		//		Attributes
		//---------------------------------------------------------------------
		private final Pattern pattern_assert = Pattern.compile("^(\\ |\\t)+assert[A-z]+(\\ |\\t)*\\((.+\\);)?");
		private String try_catch_message = "", catchType = "Throwable";
		private int endOfAssert;
		private int commentStart;
		private int roundBracketsBalance = 0;
		private boolean inAssert;
		
		
		//---------------------------------------------------------------------
		//		Methods
		//---------------------------------------------------------------------
		/**
		 * Processes a line adding try-catch to asserts so that test method
		 * execution does not stop if an assert fails.
		 * 
		 * @param		line Line to be parsed
		 * 
		 * @return		Processed line
		 */
		public String parse(String line)
		{
			int lastCurlyBracketInSameLine = line.lastIndexOf("}");
			String varname = DataUtils.generateVarName();
			
			
			// Checks if it is within a multiline assert
			if (inAssert) {
				roundBracketsBalance += getRoundBracketsBalance(line);
				
				if (roundBracketsBalance == 0) {
					inAssert = false;
					endOfAssert = line.lastIndexOf(';') + 1;
					
					if (lastCurlyBracketInSameLine != -1) {
						line = line.substring(0, lastCurlyBracketInSameLine) 
							+ "} catch(" + catchType + " " + varname + "){" + try_catch_message + "}"
							+ line.substring(lastCurlyBracketInSameLine);
					}
					else {
						line = line.substring(0, endOfAssert) 
							+ "} catch(" + catchType + " " + varname + "){" + try_catch_message + "}"
							+ line.substring(endOfAssert);
					}
				}					
			}
			// Checks if it is an assert instruction
			else if (pattern_assert.matcher(line).find()) {
				roundBracketsBalance = getRoundBracketsBalance(line);
				
				// Checks if it is an inline assert
				if (roundBracketsBalance == 0) {
					// Checks if it is a comment next to the line
					commentStart = line.indexOf("//");
					
					if (commentStart == -1)
						commentStart = line.indexOf("*/");
					
					// There is no comment next to the line
					if (commentStart == -1)
						if (lastCurlyBracketInSameLine != -1) {
							line = "try {" + line.substring(0, lastCurlyBracketInSameLine) + "} "
								+ "catch(" + catchType + " " + varname + "){" + try_catch_message + "}}";
						}
						else {
							line = "try {" + line + "} "
								+ "catch(" + catchType + " " + varname + "){" + try_catch_message + "}";
						}
					// There is a comment next to the line
					else {
						if (lastCurlyBracketInSameLine != -1) {
							line = "try {" + line.substring(0, lastCurlyBracketInSameLine)
							+ "} catch(" + catchType + " " + varname + "){" + try_catch_message + "}"
							+ line.substring(commentStart);
						}
						else {
							line = "try {" + line.substring(0, commentStart)
								+ "} catch(" + catchType + " " + varname + "){" + try_catch_message + "}"
								+ line.substring(commentStart);
						}
					}
				}
				// Multiline assert
				else {
					inAssert = true;
					line = "try {" + line;
				}
			}
			
			return line;
		}
	}
}
