package executionFlow.io.processor;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import executionFlow.io.FileEncoding;
import executionFlow.util.ConsoleOutput;
import executionFlow.util.CurlyBracketBalance;
import executionFlow.util.DataUtils;


/**
 * Responsible for pre-processing test method file. Handles exceptions
 * generated by asserts and converts JUnit 5 tests to JUnit 4 tests.
 * 
 * @author		William Niemiec &lt; williamniemiec@hotmail.com &gt;
 * @version		2.0.0
 * @since		2.0.0
 */
public class PreTestMethodFileProcessor extends FileProcessor
{
	//-------------------------------------------------------------------------
	//		Attributes
	//-------------------------------------------------------------------------
	private static final long serialVersionUID = 105L;
	
	/**
	 * If true, displays processed lines.
	 */
	private static final boolean DEBUG;
	
	private String fileExtension = "java";
	private Object testMethodArg;
	
	
	//-------------------------------------------------------------------------
	//		Initialization blocks
	//-------------------------------------------------------------------------
	/**
	 * Configures environment. If {@link #DEBUG} is true, displays processed 
	 * lines.
	 */
	static {
		DEBUG = false;
	}
	
	
	//-------------------------------------------------------------------------
	//		Constructor
	//-------------------------------------------------------------------------
	/**
	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Also, converts tests JUnit 5 to JUnit 4. Using this 
	 * constructor, file encoding will be UTF-8.
	 * 
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Name of the parsed file
	 */ 
	public PreTestMethodFileProcessor(Path filepath, Path outputDir, String outputFilename)
	{
		this.file = filepath;
		this.outputDir = outputDir;
		this.outputFilename = outputFilename;
	}
	
	/**
	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Also, converts tests JUnit 5 to JUnit 4. Using this 
	 * constructor, file encoding will be UTF-8.
	 * 
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Name of the parsed file
	 * @param		fileExtension Output file extension (without dot)
	 * (default is java)
	 */ 
	public PreTestMethodFileProcessor(Path filepath, Path outputDir, String outputFilename, String fileExtension)
	{
		this(filepath, outputDir, outputFilename);
		this.fileExtension = fileExtension;
	}
	
	/**
	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Also, converts tests JUnit 5 to JUnit 4.
	 * 
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Name of the parsed file
	 * @param		encode File encoding
	 */ 
	public PreTestMethodFileProcessor(Path filepath, Path outputDir, String outputFilename, 
			FileEncoding encode)
	{
		this(filepath, outputDir, outputFilename);
		this.encode = encode;
	}
	
	/**
	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Also, converts tests JUnit 5 to JUnit 4. Using this 
	 * constructor, file encoding will be UTF-8.
	 * 
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Name of the parsed file
	 * @param		testMethodArg Test method argument (for parameterized tests)
	 */ 
	public PreTestMethodFileProcessor(Path filepath, Path outputDir, 
			String outputFilename, FileEncoding encode, Object testMethodArg)
	{
		this(filepath, outputDir, outputFilename, encode);
		this.testMethodArg = testMethodArg;
	}
	
	/**
	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Also, converts tests JUnit 5 to JUnit 4. Using this 
	 * constructor, file encoding will be UTF-8.
	 * 
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Name of the parsed file
	 * @param		testMethodArg Test method argument (for parameterized tests)
	 * @param		fileExtension Output file extension (without dot)
	 * (default is java)
	 */ 
	public PreTestMethodFileProcessor(Path filepath, Path outputDir, 
			String outputFilename, FileEncoding encode, Object testMethodArg, 
			String fileExtension)
	{
		this(filepath, outputDir, outputFilename, encode, testMethodArg);
		this.fileExtension = fileExtension;
	}
	
	
	//-------------------------------------------------------------------------
	//		Methods
	//-------------------------------------------------------------------------
	/**
	 * Adds a try-catch structure for each assert, so that execution does not 
	 * stop even if an assert fails.
	 * 
	 * @return		Path to parsed file
	 * 
	 * @throws		IOException If file encoding is incorrect or if file cannot
	 * be read / written
	 * 
	 * @implNote	Catch will be {@link Throwable}
	 */
	@Override
	public String processFile() throws IOException
	{
		if (file == null) { return ""; }

		String line;
		File outputFile;
		AssertParser assertParser = new AssertParser();
		AnnotationParser annotationParser = new AnnotationParser(testMethodArg);

		
		// If an output directory is specified, processed file will be saved to it
		if (outputDir != null)
			outputFile = new File(outputDir.toFile(), outputFilename + "." + fileExtension);
		else	// Else processed file will be saved in current directory
			outputFile = new File(outputFilename +  "." + fileExtension);
		
		// Opens file streams (file to be parsed and output file / processed file)
		try (BufferedReader br = Files.newBufferedReader(file, encode.getStandardCharset());
			 BufferedWriter bw = Files.newBufferedWriter(outputFile.toPath(), encode.getStandardCharset())) { 
			
			// Parses file line by line
			while ((line = br.readLine()) != null) {
				line = assertParser.parse(line);
				line = annotationParser.parse(line);
				
				// -----{ DEBUG }-----
				if (DEBUG) { ConsoleOutput.showDebug(line); }
				// -----{ END DEBUG }-----
				
				bw.write(line);
				bw.newLine();
			}
		}

		return outputFile.getAbsolutePath();
	}
	
	/**
	 * Gets amount of '(' minus amount of ')' in a line.
	 * 
	 * @param		line Line to be analyzed
	 * 
	 * @return		Amount of '(' minus amount of ')' in the line
	 */
	private int getRoundBracketsBalance(String line)
	{
		return (int) (
			line.chars()
				.filter(c -> c == '(')
				.count() - 
			line.chars()
				.filter(c -> c == ')')
				.count()
		);
	}
	
	
	//-------------------------------------------------------------------------
	//		Inner classes
	//-------------------------------------------------------------------------
	/**
	 * Responsible for disabling collectors in a test method and converting
	 * JUnit 5 test annotation to JUnit 4 test annotation. 
	 */
	private class AnnotationParser
	{
		//---------------------------------------------------------------------
		//		Attributes
		//---------------------------------------------------------------------
		private boolean inTestMethodSignature = false;
		private final Pattern pattern_methodDeclaration = 
				Pattern.compile("(\\ |\\t)*([A-z0-9\\-_$<>\\[\\]\\ \\t]+(\\s|\\t))+[A-z0-9\\-_$]+"
						+ "\\(([A-z0-9\\-_$,<>\\[\\]\\ \\t])*\\)(\\{|(\\s\\{)||\\/)*");
		private String parameters = null;
		private Object testMethodArg;
		private boolean repeatedTest_putLoop;
		private boolean withinRepeatedTest;
		private String numRepetitions;
		private CurlyBracketBalance curlyBracketBalance;
		
		
		//---------------------------------------------------------------------
		//		Constructor
		//---------------------------------------------------------------------
		/**
		 * Responsible for disabling collectors in a test method and converting
		 * JUnit 5 test annotation to JUnit 4 test annotation. 
		 * 
		 * @param		testMethodArg Test method argument (for parameterized
		 * tests)
		 */
		public AnnotationParser(Object testMethodArg)
		{
			this.testMethodArg = testMethodArg;
		}
		
		/**
		 * Responsible for disabling collectors in a test method and converting
		 * JUnit 5 test annotation to JUnit 4 test annotation. Use this
		 * constructor if test method is not a parameterized test.
		 * 
		 * @param		testMethodArg Test method argument (for parameterized
		 * tests)
		 */
		@SuppressWarnings("unused")
		public AnnotationParser()
		{ }
		
		
		//---------------------------------------------------------------------
		//		Methods
		//---------------------------------------------------------------------
		/**
		 * Processes a line disabling collectors in a test method and converting
		 * JUnit 5 test annotation to JUnit 4 test annotation.
		 * 
		 * @param		line Line to be parsed
		 * 
		 * @return		Processed line
		 */
		public String parse(String line)
		{
			// Converts repeated test to while test
			if (repeatedTest_putLoop) {
				if (line.contains("{")) {
					repeatedTest_putLoop = false;
					line = repeatedTest_toLoop(line);
					
					curlyBracketBalance = new CurlyBracketBalance();
					curlyBracketBalance.parse(line);
					curlyBracketBalance.decreaseBalance();
				}
			}
			
			// Checks if it is the end of repeated test
			else if (withinRepeatedTest && curlyBracketBalance != null && line.contains("}")) {
				curlyBracketBalance.parse(line);
				
				if (curlyBracketBalance.isBalanceEmpty()) {
					int idx = line.lastIndexOf("}");
					
					
					withinRepeatedTest = false;
					curlyBracketBalance = null;
					
					line = line.substring(0, idx+1) + "}" + line.substring(idx+1);
				}
			}
			else {
				// Converts test annotation from JUnit 5 to JUnit 4
				if (line.contains("@Test")) {
					line = line.replace("@Test", "@org.junit.Test");
				}
				else if (line.contains("@org.junit.jupiter.api.Test")) {
					line = line.replace("@org.junit.jupiter.api.Test", "@org.junit.Test");
				}
				else if (line.contains("@RepeatedTest")) {
					Pattern p = Pattern.compile("@RepeatedTest\\(.*\\)");
					Matcher m = p.matcher(line);
					numRepetitions = "0";
					withinRepeatedTest = true;
					
					if (m.find()) {
						String repeatedTestAnnotation = m.group();
						line = line.replace(repeatedTestAnnotation, "@org.junit.Test @executionFlow.runtime.isRepeatedTest");
						
						// Gets number of repetitions
						m = Pattern.compile("\\(.*\\)").matcher(repeatedTestAnnotation);
						
						if (m.find()) {
							numRepetitions = m.group().replace("(", "").replace(")", "");
						}
					}
					
					repeatedTest_putLoop = true;
				}
				
				// If it is a parameterized test, converts it to a JUnit 4 test
				if (testMethodArg != null) {
					// Converts JUnit 5 parameterized test to JUnit 4 test
					if (line.contains("@ParameterizedTest")) {
						line = line.replace("@ParameterizedTest", "@org.junit.Test");
						inTestMethodSignature = true;
					}
					// Checks if it is within parameterized test
					else if (inTestMethodSignature) {
						// Converts test method parameters to local variables 
						if (line.matches(pattern_methodDeclaration.toString())) {
							// Extracts parameters
							Matcher m = Pattern.compile("\\(.*\\)").matcher(line);
							
							
							if (m.find()) {
								parameters = m.group();
								parameters = parameters.replace("(", "").replace(")", ""); // Removes parentheses
								line = line.replace(parameters, ""); // Deletes params from method
							}
						}
						// Converts parameters to local variables
						else if (parameters != null) {
							parameters = parameters + "=" + testMethodArg + ";";
							
							if (line.contains("{")) {
								int index = line.indexOf("{");
								
								
								line = line.substring(0, index+1) + parameters + line.substring(index+1);
							}
							else {
								line = parameters + line;
							}
	
							inTestMethodSignature = false;
						}
					}
				}
				
				if (curlyBracketBalance != null && withinRepeatedTest) {
					curlyBracketBalance.parse(line);
				}
			}
			
			return line;
		}
		
		private String repeatedTest_toLoop(String line)
		{
			int idx = line.lastIndexOf("{");
			String varname = DataUtils.generateVarName();
			
			
			return line.substring(0, idx + 1) + "int "+ varname + "=0;while(" +
				varname + "++ < " + numRepetitions + "){" + line.substring(idx + 1);
		}
	}
	
	/**
	 * Adds try-catch to all asserts so that test method execution does not
	 * stop if an assert fails.
	 */
	private class AssertParser
	{
		//---------------------------------------------------------------------
		//		Attributes
		//---------------------------------------------------------------------
		private final Pattern pattern_assert = Pattern.compile("^(\\ |\\t)+assert[A-z]+(\\ |\\t)*\\((.+\\);)?");
		private String try_catch_message = "", catchType = "Throwable";
		private int endOfAssert, commentStart, roundBracketsBalance = 0;
		private boolean inAssert = false;
		
		
		//---------------------------------------------------------------------
		//		Methods
		//---------------------------------------------------------------------
		/**
		 * Processes a line adding try-catch to asserts so that test method
		 * execution does not stop if an assert fails.
		 * 
		 * @param		line Line to be parsed
		 * 
		 * @return		Processed line
		 */
		public String parse(String line)
		{
			int lastCurlyBracketInSameLine = line.lastIndexOf("}");
			String varname = DataUtils.generateVarName();
			
			
			// Checks if it is within a multiline assert
			if (inAssert) {
				roundBracketsBalance += getRoundBracketsBalance(line);
				
				if (roundBracketsBalance == 0) {
					inAssert = false;
					endOfAssert = line.lastIndexOf(';') + 1;
					
					if (lastCurlyBracketInSameLine != -1) {
						line = line.substring(0, lastCurlyBracketInSameLine) 
							+ "} catch(" + catchType + " " + varname + "){" + try_catch_message + "}"
							+ line.substring(lastCurlyBracketInSameLine);
					}
					else {
						line = line.substring(0, endOfAssert) 
							+ "} catch(" + catchType + " " + varname + "){" + try_catch_message + "}"
							+ line.substring(endOfAssert);
					}
				}					
			}
			// Checks if it is an assert instruction
			else if (pattern_assert.matcher(line).find()) {
				roundBracketsBalance = getRoundBracketsBalance(line);
				
				// Checks if it is an inline assert
				if (roundBracketsBalance == 0) {
					// Checks if it is a comment next to the line
					commentStart = line.indexOf("//");
					
					if (commentStart == -1)
						commentStart = line.indexOf("*/");
					
					// There is no comment next to the line
					if (commentStart == -1)
						if (lastCurlyBracketInSameLine != -1) {
							line = "try {" + line.substring(0, lastCurlyBracketInSameLine) + "} "
								+ "catch(" + catchType + " " + varname + "){" + try_catch_message + "}}";
						}
						else {
							line = "try {" + line + "} "
								+ "catch(" + catchType + " " + varname + "){" + try_catch_message + "}";
						}
					// There is a comment next to the line
					else {
						if (lastCurlyBracketInSameLine != -1) {
							line = "try {" + line.substring(0, lastCurlyBracketInSameLine)
							+ "} catch(" + catchType + " " + varname + "){" + try_catch_message + "}"
							+ line.substring(commentStart);
						}
						else {
							line = "try {" + line.substring(0, commentStart)
								+ "} catch(" + catchType + " " + varname + "){" + try_catch_message + "}"
								+ line.substring(commentStart);
						}
					}
				}
				// Multiline assert
				else {
					inAssert = true;
					line = "try {" + line;
				}
			}
			
			return line;
		}
	}
}
