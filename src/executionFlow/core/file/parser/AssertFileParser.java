package executionFlow.core.file.parser;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import executionFlow.ConsoleOutput;
import executionFlow.core.file.FileEncoding;


/**
 * Handles exceptions generated by asserts.
 * 
 * @author		William Niemiec &lt; williamniemiec@hotmail.com &gt;
 * @version		1.5
 * @since		1.5
 */
public class AssertFileParser extends FileParser
{
	//-------------------------------------------------------------------------
	//		Attributes
	//-------------------------------------------------------------------------
	private static final long serialVersionUID = 105L;
	
	/**
	 * If true, displays processed lines.
	 */
	private static final boolean DEBUG;
	
	private Object testMethodArg;
	
	
	//-------------------------------------------------------------------------
	//		Initialization blocks
	//-------------------------------------------------------------------------
	/**
	 * Configures environment. If {@link #DEBUG} is true, displays processed 
	 * lines.
	 */
	static {
		DEBUG = true;
	}
	
	
	//-------------------------------------------------------------------------
	//		Constructor
	//-------------------------------------------------------------------------
	/**
	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails.
	 * 
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Name of the parsed file
	 * @param		encode File encoding
	 */ 
	public AssertFileParser(Path filepath, Path outputDir, String outputFilename, FileEncoding encode)
	{
		this(filepath, outputDir, outputFilename);
		this.encode = encode;
	}
	
	/**
	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Using this constructor, file encoding will be UTF-8.
	 * 
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Name of the parsed file
	 */ 
	public AssertFileParser(Path filepath, Path outputDir, String outputFilename)
	{
		this.file = filepath;
		this.outputDir = outputDir;
		this.outputFilename = outputFilename;
	}
	
	/**
	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Using this constructor, file encoding will be UTF-8.
	 * 
	 * @param		testMethodArg Test method argument (for parameterized tests)
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Name of the parsed file
	 */ 
	public AssertFileParser(Object testMethodArg, Path filepath, Path outputDir, String outputFilename, FileEncoding encode)
	{
		this(filepath, outputDir, outputFilename, encode);
		this.testMethodArg = testMethodArg;
	}
	
	
	//-------------------------------------------------------------------------
	//		Methods
	//-------------------------------------------------------------------------
	/**
	 * Adds a try-catch structure for each assert, so that execution does not 
	 * stop even if an assert fails.
	 * 
	 * @return		Path to parsed file
	 * 
	 * @throws		IOException If file encoding is incorrect or if file cannot
	 * be read / written
	 * 
	 * @implNote	Catch will be {@link Throwable}
	 */
	@Override
	public String parseFile() throws IOException
	{
		if (file == null) { return ""; }

		File outputFile;
		Pattern pattern_assert = Pattern.compile("^(\\ |\\t)+assert[A-z]+(\\ |\\t)*\\((.+\\);)?");
		String line, try_catch_message = "", catchType = "Throwable";
		int endOfAssert, commentStart, roundBracketsBalance = 0;
		boolean inAssert = false;
		boolean inTestMethodSignature = false;
		final Pattern pattern_methodDeclaration = Pattern.compile("(\\ |\\t)*([A-z0-9\\-_$<>\\[\\]\\ \\t]+(\\s|\\t))+[A-z0-9\\-_$]+\\(([A-z0-9\\-_$,<>\\[\\]\\ \\t])*\\)(\\{|(\\s\\{)||\\/)*");
		String params = null;
		
		// If an output directory is specified, processed file will be saved to it
		if (outputDir != null)
			outputFile = new File(outputDir.toFile(), outputFilename+".java");
		else	// Else processed file will be saved in current directory
			outputFile = new File(outputFilename+".java");
		
		// Opens file streams (file to be parsed and output file / processed file)
		try (BufferedReader br = Files.newBufferedReader(file, encode.getStandardCharset());
			 BufferedWriter bw = Files.newBufferedWriter(outputFile.toPath(), encode.getStandardCharset())) { 
			
			// Parses file line by line
			while ((line = br.readLine()) != null) {
				// Checks if it is within a multiline assert
				if (inAssert) {
					roundBracketsBalance += getRoundBracketsBalance(line);
					
					if (roundBracketsBalance == 0) {
						inAssert = false;
						endOfAssert = line.lastIndexOf(';') + 1;
						line = line.substring(0, endOfAssert) 
							+ "} catch(" + catchType + " e){" + try_catch_message + "}"
							+ line.substring(endOfAssert);
					}					
				}
				// Checks if it is an assert instruction
				else if (pattern_assert.matcher(line).find()) {
					roundBracketsBalance = getRoundBracketsBalance(line);
					
					// Checks if it is an inline assert
					if (roundBracketsBalance == 0) {
						// Checks if it is a comment next to the line
						commentStart = line.indexOf("//");
						
						// There is no comment next to the line
						if (commentStart == -1)
							line = "try {" + line + "} "
								+ "catch(" + catchType + " e){" + try_catch_message + "}";
						// There is a comment next to the line
						else {
							line = "try {" + line.substring(0, commentStart)
								+ "} catch(" + catchType + " e){" + try_catch_message + "}"
								+ line.substring(commentStart);
						}
					}
					// Multiline assert
					else {
						inAssert = true;
						line = "try {" + line;
					}
				}
				
				// Converts test from JUnit 5 to JUnit 4
				if (line.contains("@Test")) {
					line = line.replace("@Test", "@org.junit.Test");
				}
				else if (line.contains("@org.junit.jupiter.api.Test")) {
					line = line.replace("@org.junit.jupiter.api.Test", "@org.junit.Test");
				}
				else if (line.contains("@ValueSource")) {
					line = "";
				}
				
				// If it is a parameterized test, converts it to a JUnit 4 test
				if (testMethodArg != null) {
					// Converts JUnit 5 parameterized test to JUnit 4 test
					if (line.contains("@ParameterizedTest")) {
						line = line.replace("@ParameterizedTest", "@org.junit.Test");
						inTestMethodSignature = true;
					}
					// Checks if it is within parameterized test
					else if (inTestMethodSignature) {
						// Converts test method parameters to local variables 
						if (line.matches(pattern_methodDeclaration.toString())) {
							// Extracts parameters
							Pattern p = Pattern.compile("\\(.*\\)");
							Matcher m = p.matcher(line);
							
							
							if (m.find()) {
								params = m.group();
								params = params.replace("(", "").replace(")", ""); // Removes parentheses
								line = line.replace(params, ""); // Deletes params from method
							}
						}
						// Converts parameters to local variables
						else if (params != null) {
							params = params + "=" + testMethodArg + ";";
							
							if (line.contains("{")) {
								int index = line.indexOf("{");
								
								
								line = line.substring(0, index+1) + params + line.substring(index+1);
							}
							else {
								line = params + line;
							}
	
							inTestMethodSignature = false;
						}
					}
				}
				
				// -----{ DEBUG }-----
				if (DEBUG) { ConsoleOutput.showDebug(line); }
				// -----{ END DEBUG }-----
				
				bw.write(line);
				bw.newLine();
			}
		}

		return outputFile.getAbsolutePath();
	}
	
	/**
	 * Gets amount of '(' minus amount of ')' in a line.
	 * 
	 * @param		line Line to be analyzed
	 * 
	 * @return		Amount of '(' minus amount of ')' in the line
	 */
	private int getRoundBracketsBalance(String line)
	{
		return (int) (
			line.chars()
				.filter(c -> c == '(')
				.count() - 
			line.chars()
				.filter(c -> c == ')')
				.count()
		);
	}
}
