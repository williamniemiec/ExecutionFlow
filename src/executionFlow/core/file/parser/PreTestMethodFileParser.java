package executionFlow.core.file.parser;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import executionFlow.ConsoleOutput;
import executionFlow.core.file.FileEncoding;


/**
 * Responsible for pre-processing test method file. Handles exceptions
 * generated by asserts and converts JUnit 5 tests to JUnit 4 tests.
 * 
 * @author		William Niemiec &lt; williamniemiec@hotmail.com &gt;
 * @version		1.5
 * @since		1.5
 */
public class PreTestMethodFileParser extends FileParser
{
	//-------------------------------------------------------------------------
	//		Attributes
	//-------------------------------------------------------------------------
	private static final long serialVersionUID = 105L;
	
	/**
	 * If true, displays processed lines.
	 */
	private static final boolean DEBUG;
	
	private Object testMethodArg;
	
	
	//-------------------------------------------------------------------------
	//		Initialization blocks
	//-------------------------------------------------------------------------
	/**
	 * Configures environment. If {@link #DEBUG} is true, displays processed 
	 * lines.
	 */
	static {
		DEBUG = true;
	}
	
	
	//-------------------------------------------------------------------------
	//		Constructor
	//-------------------------------------------------------------------------
	/**
	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails.
	 * 
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Name of the parsed file
	 * @param		encode File encoding
	 */ 
	public PreTestMethodFileParser(Path filepath, Path outputDir, String outputFilename, FileEncoding encode)
	{
		this(filepath, outputDir, outputFilename);
		this.encode = encode;
	}
	
	/**
	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Using this constructor, file encoding will be UTF-8.
	 * 
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Name of the parsed file
	 */ 
	public PreTestMethodFileParser(Path filepath, Path outputDir, String outputFilename)
	{
		this.file = filepath;
		this.outputDir = outputDir;
		this.outputFilename = outputFilename;
	}
	
	/**
	 * Handles exceptions generated by asserts. Specifically,  adds a try-catch
	 * structure for each assert, so that execution does not stop even if an 
	 * assert fails. Using this constructor, file encoding will be UTF-8.
	 * 
	 * @param		testMethodArg Test method argument (for parameterized tests)
	 * @param		filename Path of the file to be parsed
	 * @param		outputDir Directory where parsed file will be saved
	 * @param		outputFilename Name of the parsed file
	 */ 
	public PreTestMethodFileParser(Object testMethodArg, Path filepath, Path outputDir, String outputFilename, FileEncoding encode)
	{
		this(filepath, outputDir, outputFilename, encode);
		this.testMethodArg = testMethodArg;
	}
	
	
	//-------------------------------------------------------------------------
	//		Methods
	//-------------------------------------------------------------------------
	/**
	 * Adds a try-catch structure for each assert, so that execution does not 
	 * stop even if an assert fails.
	 * 
	 * @return		Path to parsed file
	 * 
	 * @throws		IOException If file encoding is incorrect or if file cannot
	 * be read / written
	 * 
	 * @implNote	Catch will be {@link Throwable}
	 */
	@Override
	public String parseFile() throws IOException
	{
		if (file == null) { return ""; }

		String line;
		File outputFile;
		AssertParser assertParser = new AssertParser();
		AnnotationParser annotationParser = new AnnotationParser(testMethodArg);

		
		// If an output directory is specified, processed file will be saved to it
		if (outputDir != null)
			outputFile = new File(outputDir.toFile(), outputFilename+".java");
		else	// Else processed file will be saved in current directory
			outputFile = new File(outputFilename+".java");
		
		// Opens file streams (file to be parsed and output file / processed file)
		try (BufferedReader br = Files.newBufferedReader(file, encode.getStandardCharset());
			 BufferedWriter bw = Files.newBufferedWriter(outputFile.toPath(), encode.getStandardCharset())) { 
			
			// Parses file line by line
			while ((line = br.readLine()) != null) {
				line = assertParser.parse(line);
				line = annotationParser.parse(line);
				
				// -----{ DEBUG }-----
				if (DEBUG) { ConsoleOutput.showDebug(line); }
				// -----{ END DEBUG }-----
				
				bw.write(line);
				bw.newLine();
			}
		}

		return outputFile.getAbsolutePath();
	}
	
	/**
	 * Gets amount of '(' minus amount of ')' in a line.
	 * 
	 * @param		line Line to be analyzed
	 * 
	 * @return		Amount of '(' minus amount of ')' in the line
	 */
	private int getRoundBracketsBalance(String line)
	{
		return (int) (
			line.chars()
				.filter(c -> c == '(')
				.count() - 
			line.chars()
				.filter(c -> c == ')')
				.count()
		);
	}
	
	
	//-------------------------------------------------------------------------
	//		Inner classes
	//-------------------------------------------------------------------------
	/**
	 * Responsible for disabling collectors in a test method and converting
	 * JUnit 5 test annotation to JUnit 4 test annotation. 
	 */
	private class AnnotationParser
	{
		//---------------------------------------------------------------------
		//		Attributes
		//---------------------------------------------------------------------
		private boolean inTestMethodSignature = false;
		private final Pattern pattern_methodDeclaration = Pattern.compile("(\\ |\\t)*([A-z0-9\\-_$<>\\[\\]\\ \\t]+(\\s|\\t))+[A-z0-9\\-_$]+\\(([A-z0-9\\-_$,<>\\[\\]\\ \\t])*\\)(\\{|(\\s\\{)||\\/)*");
		private String params = null;
		private Object testMethodArg;
		
		
		//---------------------------------------------------------------------
		//		Constructor
		//---------------------------------------------------------------------
		/**
		 * Responsible for disabling collectors in a test method and converting
		 * JUnit 5 test annotation to JUnit 4 test annotation. 
		 * 
		 * @param		testMethodArg Test method argument (for parameterized
		 * tests)
		 */
		public AnnotationParser(Object testMethodArg)
		{
			this.testMethodArg = testMethodArg;
		}
		
		/**
		 * Responsible for disabling collectors in a test method and converting
		 * JUnit 5 test annotation to JUnit 4 test annotation. Use this
		 * constructor if test method is not a parameterized test.
		 * 
		 * @param		testMethodArg Test method argument (for parameterized
		 * tests)
		 */
		@SuppressWarnings("unused")
		public AnnotationParser()
		{ }
		
		
		//---------------------------------------------------------------------
		//		Methods
		//---------------------------------------------------------------------
		/**
		 * Parses a line disabling collectors in a test method and converting
		 * JUnit 5 test annotation to JUnit 4 test annotation.
		 * 
		 * @param		line Line to be parsed
		 * 
		 * @return		Parsed line
		 */
		public String parse(String line)
		{
			// Converts test annotation from JUnit 5 to JUnit 4
			if (line.contains("@Test")) {
				line = line.replace("@Test", "@org.junit.Test");
			}
			else if (line.contains("@org.junit.jupiter.api.Test")) {
				line = line.replace("@org.junit.jupiter.api.Test", "@org.junit.Test");
			}
			else if (line.contains("@RepeatedTest")) {
				Pattern p = Pattern.compile("@RepeatedTest\\(.*\\)");
				Matcher m = p.matcher(line);
				
				if (m.find()) { 
					line = line.replace(m.group(), "@org.junit.Test");
				}
			}
			
			// If it is a parameterized test, converts it to a JUnit 4 test
			if (testMethodArg != null) {
				// Converts JUnit 5 parameterized test to JUnit 4 test
				if (line.contains("@ParameterizedTest")) {
					line = line.replace("@ParameterizedTest", "@org.junit.Test");
					inTestMethodSignature = true;
				}
				// Checks if it is within parameterized test
				else if (inTestMethodSignature) {
					// Converts test method parameters to local variables 
					if (line.matches(pattern_methodDeclaration.toString())) {
						// Extracts parameters
						Pattern p = Pattern.compile("\\(.*\\)");
						Matcher m = p.matcher(line);
						
						
						if (m.find()) {
							params = m.group();
							params = params.replace("(", "").replace(")", ""); // Removes parentheses
							line = line.replace(params, ""); // Deletes params from method
						}
					}
					// Converts parameters to local variables
					else if (params != null) {
						params = params + "=" + testMethodArg + ";";
						
						if (line.contains("{")) {
							int index = line.indexOf("{");
							
							
							line = line.substring(0, index+1) + params + line.substring(index+1);
						}
						else {
							line = params + line;
						}

						inTestMethodSignature = false;
					}
				}
			}
			
			return line;
		}
	}
	
	/**
	 * Adds try-catch to all asserts so that test method execution does not
	 * stop if an assert fails.
	 */
	private class AssertParser
	{
		//---------------------------------------------------------------------
		//		Attributes
		//---------------------------------------------------------------------
		private final Pattern pattern_assert = Pattern.compile("^(\\ |\\t)+assert[A-z]+(\\ |\\t)*\\((.+\\);)?");
		private String try_catch_message = "", catchType = "Throwable";
		private int endOfAssert, commentStart, roundBracketsBalance = 0;
		private boolean inAssert = false;
		
		
		//---------------------------------------------------------------------
		//		Methods
		//---------------------------------------------------------------------
		/**
		 * Parses a line adding try-catch to asserts so that test method
		 * execution does not stop if an assert fails.
		 * 
		 * @param		line Line to be parsed
		 * 
		 * @return		Parsed line
		 */
		public String parse(String line)
		{
			// Checks if it is within a multiline assert
			if (inAssert) {
				roundBracketsBalance += getRoundBracketsBalance(line);
				
				if (roundBracketsBalance == 0) {
					inAssert = false;
					endOfAssert = line.lastIndexOf(';') + 1;
					line = line.substring(0, endOfAssert) 
						+ "} catch(" + catchType + " e){" + try_catch_message + "}"
						+ line.substring(endOfAssert);
				}					
			}
			// Checks if it is an assert instruction
			else if (pattern_assert.matcher(line).find()) {
				roundBracketsBalance = getRoundBracketsBalance(line);
				
				// Checks if it is an inline assert
				if (roundBracketsBalance == 0) {
					// Checks if it is a comment next to the line
					commentStart = line.indexOf("//");
					
					// There is no comment next to the line
					if (commentStart == -1)
						line = "try {" + line + "} "
							+ "catch(" + catchType + " e){" + try_catch_message + "}";
					// There is a comment next to the line
					else {
						line = "try {" + line.substring(0, commentStart)
							+ "} catch(" + catchType + " e){" + try_catch_message + "}"
							+ line.substring(commentStart);
					}
				}
				// Multiline assert
				else {
					inAssert = true;
					line = "try {" + line;
				}
			}
			
			return line;
		}
	}
}
